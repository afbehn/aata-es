<?xml version="1.0" encoding="UTF-8"?>
<!-- This file is part of the book                    -->
<!--                                                  -->
<!-- Abstract Algebra: Theory and Applications        -->
<!--                                                  -->
<!-- Text: Copyright (C) 1997-2023  Thomas W. Judson  -->
<!-- Sage: Copyright (C) 2010-2023 Robert A. Beezer  -->
<!-- See the file COPYING for copying conditions.     -->
<!-- This file is part of the book                    -->
<!--                                                  -->
<!-- See the file COPYING for copying conditions.     -->
<chapter xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="crypt" permid="uCn">
  <title>Introducción a la Criptografía</title>

  <introduction permid="YyK">

    <p permid="WCt">La Criptografía trata del envío y recepción de mensaje secretos. El objetivo de la criptografía es enviar mensajes de manera que solo el destinatario deseado pueda leerlos. Además, al recibirlo, el destinatario requiere de cierta garantía de autenticidad; es decir que no ha sido enviado por alguien que lo esté tratando de engañar. La criptografía moderna depende fuertemente del álgebra abstracta y de la teoría de números.
    </p> 

    <p permid="CJC">El mensaje a enviar lo llamaremos <term>texto claro</term><idx><h>Texto claro</h></idx>. El mensaje encubierto se llamará <idx><h>Texto cifrado</h></idx><term>texto cifrado</term>. Tanto el texto claro como el texto cifrado están escritos en un  <term>alfabeto</term>, que consiste de <term>letras</term> o <term>caracteres</term>. Los caracteres pueden incluir no solamente  las letras usuales como A, <m>\ldots</m>, Z y a, <m>\ldots</m>, z sino también dígitos, marcas de puntuación, y espacios. Un <term>criptosistema</term>,<idx><h>Criptosistema</h><h>definición de</h></idx> o <idx><h>Cifrado</h></idx> <term>cifrado</term>,  tiene dos partes: <term>encriptación</term>, el proceso de transformar un texto claro en un texto cifrado, y <term>decriptación</term>, la transformación inversa del texto cifrado al texto plano.
    </p>
 
    <p permid="iQL">Hay diversas familias de criptosistemas, cada una se distingue por un algoritmo particular de encriptación. Los criptosistemas en una familia específica se distinguen entre ellos por un parámetro de la función de encriptación llamado <idx><h>Key</h><h>definición de</h></idx><term>key (clave)</term>. Un criptosistema clásico tiene una sola clave, que debe ser mantenida en secreto,  solo conocida por el remitente y el destinatario del mensaje. Si una persona <m>A</m> desea enviar mensajes secretos a dos personas diferentes <m>B</m> y <m>C</m>, y no quiere que <m>B</m> entienda el mensaje enviado a <m>C</m> ni viceversa, entonces <m>A</m> debe usar dos claves diferentes, un criptosistema para intercambiar mensajes con <m>B</m>, y otro para intercambiar mensajes con <m>C</m>.
    </p>

    <p permid="OXU">Los sistemas que usan dos claves separadas, una para encriptar y otra para decriptar, se conocen como <idx><h>Llave</h><h>pública</h></idx><idx><h>Criptosistema</h><h>Llave pública</h></idx><term>criptosistemas de clave pública</term>. Como el conocimiento de la clave de encriptación no le permite a nadie adivinar la clave de decriptación, la primera se puede hacer pública. Un criptosistema de clave pública le permite tanto a <m>A</m> como a <m>B</m> enviar mensajes a <m>C</m> usando la misma clave de encriptación.  Cualquiera puede encriptar mensajes para enviarselos a <m>C</m>, pero solo <m>C</m> sabe como decriptar estos mensajes.
    </p>

  </introduction>

  <section xml:id="crypt-section-private-key" permid="Qkr">
    <title>Criptografía de Clave Privada</title>
    
    <p permid="ztx">En criptosistemas de clave <idx><h>Clave</h><h>única</h></idx><idx><h>Criptosistema</h><h>clave única</h></idx><term>única</term> o <term>criptosistema de clave privada</term><idx><h>Clave</h><h>privada</h></idx><idx><h>Criptosistema</h><h>clave privada</h></idx> la misma clave se usa tanto para encriptar como para decriptar los mensajes. Para encriptar un texto-claro, aplicamos al mensaje alguna función que se mantiene en secreto, digamos <m>f</m>. Esta función devuelve un mensaje encriptado.  Dada la forma encriptada del mensaje, podemos recuperar el mensaje original aplicando la transformación inversa <m>f^{-1}</m>. La transformación <m>f</m> debe ser relativamente fácil de calcular, así como también lo debe ser <m>f^{-1}</m>; pero, <m>f</m> tiene que ser muy difícil de adivinar a partir de ejemplos disponibles de mensajes encriptados.
    </p>


    <example xml:id="crypt-example-caesar" permid="zWa">
      <p permid="RSA">Uno de los primeros y más famosos criptosistemas fue el código de desplazamiento usado por Julio César.  Primero convertimos el alfabeto en números haciendo <m>\text{A}  = 00, \text{B}  = 01, \ldots, \text{Z} = 25</m>. La función codificadora será 
        <me permid="QrI">f(p) = p + 3 \bmod 26;</me>
      es decir, <m>A \mapsto D, B \mapsto E, \ldots, Z \mapsto C</m>. La función decodificadora es entonces 
        <me permid="wyR">f^{-1}(p) = p - 3 \bmod 26 = p + 23 \bmod 26</me>.
      Supongamos que recibimos el mensaje encriptado DOJHEUD. Para decriptar este mensaje, lo convertimos a números:  
        <me permid="cGa">3, 14, 9, 7, 4, 20, 3</me>.
      Luego le aplicamos la transformación inversa para obtener
        <me permid="INj">0, 11, 6, 4, 1, 17, 0</me>,
      es decir ALGEBRA. Note que no hay nada especial en los números <m>3</m> y <m>26</m>, podríamos usar un alfabeto mayor o un desplazamiento diferente.
    </p>
    </example>
 
    <p permid="LHP">El <term>criptoanálisis</term><idx><h>Criptoanálisis</h></idx> se preocupa de descifrar un mensaje encriptado recibido o interceptado. Existen métodos de probabilidades y estadísticas que son de gran ayuda al descifrar mensajes interceptados; por ejemplo, el análisis de frecuencia de los caracteres que aparecen en el mensaje encriptado puede hacer posible su decriptación.
    </p>

    <example xml:id="crypt-example-analysis" permid="gdj">
      <p permid="xZJ">Supongamos que recibimos un mensaje que sabemos fue encriptado usando un desplazamiento en las <m>26</m> letras del alfabeto. Para determinar el desplazamiento ocupado, debemos encontrar <m>b</m> en la ecuación <m>f(p) = p + b \bmod 26</m>. Podemos hacer esto usando análisis de frecuencia.  La letra <m>\text{E} = 04</m> es la más frecuente en el idioma inglés. Supongamos que <m>\text{S} = 18</m> es la letra que ocurre con más frecuencia en el texto-cifrado.  Entonces tenemos una buena razón para sospechar que <m>18 = 4 + b \bmod 26</m>, y <m>b= 14</m>. Por lo tanto, la función encriptadora más probable es 
        <me permid="oUs">f(p) = p + 14 \bmod 26</me>.
      La correspondiente función decriptadora es 
        <me permid="VbB">f^{-1}(p) = p + 12 \bmod 26</me>.
      En este punto es fácil determinar si la sospecha es o no correcta.
    </p>
    </example>

    <p permid="rOY">Códigos de desplazamiento simple son ejemplos de <idx><h>Criptosistema</h><h>monoalfabético</h></idx><term>criptosistemas monoalfabéticos</term>. En estos cifrados un caracter en el texto-cifrado representa exactamente un caracter en el mensaje original. Tales criptosistemas no son muy sofisticados y son muy fáciles de romper. De hecho, en un desplazamiento simple como el descrito en el <xref ref="crypt-example-caesar"/>, existen solo <m>26</m> claves posibles. Sería muy fácil probarlas todas en lugar de usar el análisis de frecuencia.
    </p> 

    <p permid="XWh">Investigemos un criptosistema ligeramente más sofisticado. Supongamos que la función encriptadora está dada por  
      <me permid="BiK">f(p) = ap + b \bmod 26</me>.
    Primero debemos determinar cuándo existe una función decriptadora <m>f^{-1}</m>. Tal función existe cuando podemos resolver la ecuación
      <me permid="hpT">c = ap + b \bmod 26</me>
    en <m>p</m>. Por la <xref ref="groups-proposition-zn-equiv-classes"/>, esto es posible precisamente cuando <m>a</m> tiene inverso, es decir cuando <m>\gcd( a, 26) =1</m>. En este caso 
      <me permid="Nxc">f^{-1}(p) = a^{-1} p - a^{-1} b \bmod 26</me>.
    Un criptosistema de este tipo se denomina <idx><h>Criptosistema</h><h>afín</h></idx><term>criptosistema afín</term>.
    </p>
 
    <example xml:id="crypt-example-affine-crypt" permid="Mks">
      <p permid="egS">Consideremos el criptosistema afín <m>f(p) = ap + b \bmod 26</m>. Para que este criptosistema funcione, debemos elegir <m>a \in {\mathbb Z}_{26}</m> que sea invertible. Esto solo es posible si <m>\gcd(a, 26) = 1</m>. Reconociendo este hecho,  elegiremos <m>a = 5</m> pues <m>\gcd(5, 26) = 1</m>. Es muy fácil ver que <m>a^{-1} = 21</m>. Por lo tanto, podemos definir nuestra función de encriptación como <m>f(p) = 5p + 3 \bmod 26</m>. Luego, ALGEBRA se encripta como <m>3, 6, 7, 23, 8, 10, 3</m>, o DGHXIKD. La función decriptadora será   
        <me permid="tEl">f^{-1}(p) = 21 p - 21 \cdot 3 \bmod 26 = 21 p + 15 \bmod 26</me>.
    </p>
    </example> 
 
    <p permid="Edq">Un criptosistema sería más seguro si una letra del texto-cifrado pudiese representar más de una letra del texto-claro.  Para dar un ejemplo de este tipo de criptosistema, llamado <term>criptosistema polialfabético</term>,<idx><h>Criptosistema</h><h>polialfabético</h></idx> generalizaremos los códigos afines usando matrices. La idea funciona básicamente como antes; sin embargo, en lugar de encriptar una letra a la vez, encriptaremos pares de letras.  Podemo almacenar un par de letras <m>p_1</m> y <m>p_2</m> en un vector  
      <me permid="ZLu">{\mathbf p} = 
      \begin{pmatrix}
      p_1 \\ p_2
      \end{pmatrix}</me>.
    Sea <m>A</m> una matriz invertible de <m>2 \times 2</m> con coeficientes en <m>{\mathbb Z}_{26}</m>. Podemos definir una función encriptadora como
      <me permid="FSD">f({\mathbf p}) = A {\mathbf p} + {\mathbf b}</me>,
    donde <m>{\mathbf b}</m> es un vector columna fijo y las operaciones matriciales se llevan a cabo en <m>{\mathbb Z}_{26}</m>. La función decriptadora debe ser
      <me permid="lZM">f^{-1}({\mathbf p}) = A^{-1} {\mathbf p} - A^{-1} {\mathbf b}</me>.
    </p>
 
    <example xml:id="crypt-example-help" permid="srB">
      <p permid="Kob">Supongamos que deseamos encriptar la palabra HELP. Los números correspondientes son <m>7, 4, 11, 15</m>. Si
        <me permid="SgV">A =
        \begin{pmatrix}
        3 &amp; 5 \\
        1 &amp; 2
        \end{pmatrix}</me>,
      entonces
        <me permid="yoe">A^{-1} 
        =
        \begin{pmatrix}
        2 &amp; 21 \\
        25 &amp; 3
        \end{pmatrix}</me>.
      Si <m>{\mathbf b} = ( 2, 2)^ \transpose</m>, entonces el mensaje encriptado queda como RRGR. La letra R representa más de una letra en el texto-claro.
    </p>
    </example>
 
    <p permid="kkz">El análisis de frecuencia aún es realizable en un criptosistema polialfabético, pues tenemos buena información sobre la frecuencia relativa de pares de letras en el idioma inglés. El par <em>th</em> aparece con gran frecuencia; el par <em>qz</em> nunca aparece.  Para evitar decriptación por parte de un tercero, debemos usar una matriz de mayor tamaño que la usada en el <xref ref="crypt-example-help"/>.
    </p>

<!-- TWJ 4/7/2010 Need to resolve this reference -->

  </section>

  <section xml:id="crypt-section-public-key" permid="wrA">
    <title>Criptografía de Clave Pública</title>

    <introduction permid="EFT">
 
      <p permid="vfd">Si se usan criptosistemas tradicionales, cualquiera que sea capaz de encriptar un mensaje, también tendrá información suficiente para decriptar un mensaje interceptado. En 1976, W. Diffie<idx><h>Diffie, W.</h></idx> y M. Hellman<idx><h>Hellman, M.</h></idx> propusieron la criptografía de clave pública, que está basada en la observación de que los procesos de encriptación y decriptación no necesitan tener la misma clave. Esto quita el requerimiento de que la clave de encriptación sea secreta. La función encriptadora <m>f</m> debe ser relativamente fácil de calcular, pero <m>f^{-1}</m> tiene que ser muy difícil de calcular sin alguna información adicional, de manera que alguien que conozca la clave de encriptación, no pueda descubrir la clave de decriptación sin pasar por cálculos prohibitivamente difíciles. Es interesante notar que hasta la fecha para ningún método propuesto se ha demostrado que es <q>unidireccional;</q> es decir, para ningún criptosistema de clave pública existente, se ha demostrado que sea computacionalmente prohibitivo descifrar el mensaje con el solo conocimiento de la clave de encriptación.
    </p>

    </introduction>

    <subsection xml:id="crypt-subsection-rsa" permid="aJw">
      <title>El Criptosistema <acro>RSA</acro></title>

         <p permid="rfe">El Criptosistema <acro>RSA</acro> introducido por R. Rivest<idx><h>Rivest, R.</h></idx>, A.  Shamir<idx><h>Shamir, A.</h></idx>, y L. Adleman<idx><h>Adleman, L.</h></idx> en 1978, se basa en la dificultad de factorizar número grandes. Si bien no es difícil encontrar dos primos aleatorios grandes y multiplicarlos, factorizar un número de 150 dígitos que sea el producto de dos primos grandes requería de 100 millones de computadores operando 10 millones de instrucciones por segundo durante 50 millones de años con los mejores algoritmos conocidos a principios de la década de 1990.  Si bien los algoritmos se han mejorado, factorizar un producto de dos primos grandes sigue siendo computacionalmente prohibitivo.
    </p>

        <p permid="Xmn">El Criptosistema <acro>RSA</acro><idx><h><acro>RSA</acro> criptosistema</h></idx><idx><h>Criptosistema</h><h><acro>RSA</acro></h></idx> funciona como sigue. Supongamos que escogemos al azar dos números primos <m>p</m> y <m>q</m> de 150 dígitos cada uno. Después calculamos su producto <m>n= pq</m> y también calculamos <m>\phi(n) = m = (p - 1)(q-1)</m>, donde <m>\phi</m> es la función <m>\phi</m> de Euler.  Ahora comenzamos a elegir enteros aleatorios <m>E</m> hasta que encontremos uno que sea relativamente primo con <m>m</m>; es decir, elegimos <m>E</m> tal que <m>\gcd(E, m) = 1</m>. Usando el algoritmo de Euclides, podemos encontrar un número <m>D</m> tal que <m>DE \equiv 1 \pmod{m}</m>. Los números <m>n</m> y <m>E</m> ahora se hacen públicos.
    </p>
 
        <p permid="Dtw">Supongamos que la persona B (Bob) desea enviar a la persona A (Alice) un mensaje a través de un canal abierto (público). Como <m>E</m> y <m>n</m> son conocidos para todo el mundo, cualquiera puede encriptar mensajes. Bob primero convierte su mensaje en una cadena numérica de acuerdo a algún procedimiento, digamos <m>\text{A}  = 00, \text{B}  = 02, \ldots, \text{Z}= 25</m>. Si es necesario, descompondrá su mensaje de manera que cada pedazo sea un entero positivo menor a <m>n</m>.  Supongamos que <m>x</m> es uno de estos pedazos.  Bob forma el número <m>y = x^E \mod n</m> y envía <m>y</m> a Alice. Para que Alice recupere <m>x</m>, ella solo necesita calcular <m>x = y^D \bmod n</m>. Solo Alice conoce <m>D</m>.
    </p>
 
      <example xml:id="crypt-example-rsa" permid="IFS">
        <p permid="qvk">Antes de explorar la teoría tras el criptosistema <acro>RSA</acro> o intentar usar enteros grandes, usaremos algunos enteros pequeños simplemente para ver que el sistema realmente funciona. Supongamos que el mensaje que deseamos enviar, una vez digitalizado es <m>25</m>. Sean <m>p = 23</m> y <m>q = 29</m>. Entonces 
          <me permid="evn">n = pq = 667</me>
        y
          <me permid="KCw">\phi(n) = m = (p - 1)(q - 1) = 616</me>.
        Podemos elegir <m>E = 487</m>, pues <m>\gcd(616, 487) = 1</m>. El mensaje codificado lo calculamos como 
          <me permid="qJF">25^{487} \bmod 667 = 169</me>.
        Este cálculo se puede realizar de forma razonable usando el método de los cuadrados repetidos descrito en el Capí<xref ref="cyclic"/>. Usando el algoritmo de Euclides, determinamos que <m>191 E = 1 + 151 m</m>; por lo tanto, la clave de decriptación es <m>(n, D) = ( 667, 191)</m>. Podemos recuperar el mensaje original calculando  
          <me permid="WQO">169^{191} \bmod 667 = 25</me>.
    </p>
      </example>

<!-- Message changed from 23 to 25 so that it does not match p.  Suggested by R. Beezer. -->
<!-- TWJ - 12/19/2011 -->

      <p permid="jAF">Examinemos ahora por qué funciona el criptosistema <acro>RSA</acro>.  Sabemos que <m>DE \equiv 1 \pmod{ m}</m>; luego, existe <m>k</m> tal que 
        <me permid="CXX">DE = km + 1 = k \phi(n) + 1</me>.
      Debemos considerar dos casos.  En el primer caso supongamos que <m>\gcd(x, n) = 1</m>.  Entonces, por el <xref ref="cosets-theorem-eulers_theorem"/>,
        <me permid="jfg">y^D = (x^E)^D = x^{DE} = x^{km + 1} = (x^{\phi(n)})^k x = (1)^k x = x \bmod n</me>.
      De esta manera vemos que Alice recupera el mensaje original <m>x</m> cuando calcula <m>y^D \bmod n</m>.
    </p>

      <p permid="PHO">Para el otro caso, supongamos que <m>\gcd(x, n) \neq 1</m>.  Como <m>n = pq</m> y <m>x \lt n</m>, sabemos que <m>x</m> es un múltiplo de <m>p</m> o un múltiplo de <m>q</m>, pero no ambos.  Describiremos solo la primera posibilidad, pues la otra es completamente similar.  Entonces existe un entero <m>r</m>, con <m>r \lt q</m> y <m>x = rp</m>.  Notemos que tenemos <m>\gcd(x, q) = 1</m> y que <m>m=\phi(n)=(p - 1)(q - 1)=\phi(p)\phi(q)</m>.  Entonces, usando el <xref ref="cosets-theorem-eulers_theorem"/>, pero ahora mód <m>q</m>,
        <me permid="Pmp">x^{km} = x^{k\phi(p)\phi(q)} = (x^{\phi(q)})^{k\phi(p)} = (1)^{k\phi(p)} = 1 \bmod q</me>.
      Existe un entero <m>t</m> tal que <m>x^{km}=1 + tq</m>. Luego, Alice también recupera el mensaje en este caso,
        <me permid="vty">y^D = x^{km + 1} = x^{km} x = (1 + tq) x = x + tq(rp) = x + trn = x \bmod n</me>.
    </p>


<!-- Demonstration expanded to two cases.  Suggested by Kevin Halasz. -->
<!-- RAB - 12/30/2011 -->

      <p permid="vOX">Podemos preguntarnos ahora como uno intentaría violar el criptosistema <acro>RSA</acro>. Para encontrar <m>D</m> dados <m>n</m> y <m>E</m>, necesitamos factorizar <m>n</m> y encontrar <m>D</m> usando el algoritmo de Euclides. Si supiéramos que <m>667 = 23 \cdot 29</m> en el <xref ref="crypt-example-rsa"/>, podríamos recuperar <m>D</m>.
    </p>    

    </subsection>
    
    <subsection xml:id="crypt-subsection-message-verification" permid="GQF">
      <title>Verificación del Mensaje</title>
         
       <p permid="bWg">Hay un problema de verificación de mensajes en los criptosistemas de clave pública. Como la clave codificadora es de público conocimiento, cualquiera tiene la capacidad de enviar un mensaje codificado.  Si Alice recibe un mensaje de Bob, a ella le gustaría poder verificar que realmente fue Bob quien envió el mensaje. Supongamos que la clave encriptadora de Bob es <m>(n', E')</m> y su clave decriptadora es <m>(n', D')</m>.  Además, supongamos que la clave encriptadora de Alice es <m>(n, E)</m> y que su clave decriptadora es <m>(n, D)</m>.  Como las claves encriptadoras son de conocimiento público, ambos pueden intercambiar mensajes cuando lo deseen.  Bob quiere poder asegurarle a Alice que el mensaje que le está enviando es auténtico. Antes de enviar el mensaje <m>x</m> a Alice, Bob decripta <m>x</m> con su propia clave secreta:
        <me permid="bAH">x' = x ^{D'} \bmod n'</me>.
      Cualquiera puede transformar <m>x'</m> de vuelta a <m>x</m> encriptando, pero solo Bob tiene la habilidad de formar <m>x'</m>. Ahora Bob encripta <m>x'</m> con la clave pública de Alice formando 
        <me permid="HHQ">y' = {x'}^E  \bmod n</me>,
      un mensaje que solo Alice puede decriptar.  Alice decripta el mensaje y luego encripta el resultado con la clave de encriptación de Bob para leer el mensaje original, un mensaje que solo puede haber sido enviado por Bob.
    </p>

    </subsection>
 
    <subsection xml:id="crypt-subsection-historical-note" permid="mXO">
      <title>Nota Histórica</title>
      
      <p permid="Idp">La idea de encriptar mensajes secretos se remonta a la Antiguedad. Como sabemos, Julio César usaba un código de desplazamiento simple para enviar y recibir mensajes. Sin embargo, el estudio formal de la codificación y decodificación de mensajes probablemente comenzó con los árabes en el siglo XV. En los siglos XV y XVI, matemáticos como Alberti y Viete descubrieron que los criptosistemas monoalfabéticos no ofrecían ninguna seguridad real. En el siglo XIX, F. W. Kasiski estableció métodos para violar sistemas en los que una letra del texto encriptado puede representar más de una letra del texto claro, si la misma clave era usada varias veces. Este descubrimiento llevó al uso de criptosistemas con claves que se usaban solo una vez. La Criptografía obtuvo fundamentos matemáticos firmes con los trabajos de gente como W. Friedman y L. Hill a comienzos del siglo XX.
    </p>
 
      <p permid="oky">El período que siguió a la Primera Guerra Mundial vio el desarrollo de máquinas especializadas para la encriptación y decriptación de mensajes, y los matemáticos trabajaron muy activamente en criptografía durante la Segunda Guerra Mundial. Los esfuerzos por penetrar los criptosistemas de las naciones del Eje fueron organizados en Inglaterra y en los Estados Unidos por matemáticos notables como Alan Turing y A. A. Albert.  Los Aliados obtuvieron una tremenda ventaja en la Segunda Guerra Mundial al romper los sistemas de encriptación producidos por la máquina Enigma de Alemania y los cifrados Púrpura de Japón.
    </p>

      <p permid="UrH">Hacia 1970, el interés en la criptografía comercial comenzó a solidificarse. Había una necesidad creciente de proteger transacciones bancarias, datos informáticos y correo electrónico. A comienzos de los 70, <acro>IBM</acro> desarrolló e implementó <acro>LUZIFER</acro>, el precursor de estándar de encriptación de datos del National Bureau of Standards de Estados Unidos.
    </p>

      <p permid="AyQ">El concepto de un criptosistema de clave pública, debido a Diffie y Hellman, es muy reciente (1976). Su desarrollo fue continuado por Rivest, Shamir, y Adleman con el criptosistema <acro>RSA</acro> (1978). No se sabe qué tan seguros son estos criptosistemas. El criptosistema de la mochila de decisión, desarrollado por Merkle y Hellman, ya fue roto. Es aún una pregunta abierta si el sistema <acro>RSA</acro> puede o no ser roto. En 1991, los Laboratorios <acro>RSA</acro> publicaron una lista de semiprimos (números que tienen exactamente dos factores primos) con un premio en dinero para quien pudiera factorizarlos (<url href="http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm" visual="www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm">http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm</url>).  Si bien el desafío terminó en 2007, muchos de estos números aún no han sido factorizados.
    </p>
      
      <p permid="gFZ">Ha habido bastante controversia en relación a la investigación de criptosistemas, la criptografía en sí. En 1929, cuando Henry Stimson, Secretario de Estado de Herbert Hoover, disolvió la Cámara Negra (la división de criptografía del Departamento de Estado) con la justificación ética de que <q>los caballeros no leen la correspondencia de otros</q>.  Durante las últimas dos décadas del siglo XX, la Agencia Nacional de Seguridad (NSA) quería mantener en secreto la información sobre criptografía, mientras la comunidad científica peleó por el derecho de publicar la ciencia básica relacionada.  Actualmente, la investigación en criptografía matemática y la teoría de números computacional es muy activa, y los matemáticos tienen la libertad de publicar sus resultados en estas áreas.
    </p> 

    </subsection>

    <paragraphs component="sage-blurb" permid="kdi">
      <title>Sage</title>
    
      <p permid="Tmo">El desarrollo inicial de Sage tuvo rutinas poderosas para la teoría de números, y luego comenzó a incluir estructuras algebraicas y otras áreas de las matemáticas discretas.  Es por lo tanto una herramienta natural para el estudio de criptografía, incluyendo tópicos tales como RSA, criptografía de curvas elípticas, y AES (Advanced Encryption Standard o estándar avanzado de encriptación).
    </p>
      
    </paragraphs>

  </section>
 
  <reading-questions permid="Jzd">

    <exercise permid="Mtj">
      <statement>
        <p permid="Rdc">
          Utilice la función <c>euler_phi()</c> en Sage para calcular <m>\phi(893\,456\,123)</m>.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="sAs">
      <statement>
        <p permid="xkl">
          Utilice la función <c>power_mod()</c> en Sage para calcular <m>7^{324}\pmod{895}</m>.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="YHB">
      <statement>
        <p permid="dru">
          Explique la base matemática para decir:
          cifrar un mensaje usando una clave pública <init>RSA</init> es muy simple desde el punto de vista computacional,
          mientras que descifrar una comunicación sin la clave privada es muy difícil desde el punto de vista computacional.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="EOK">
      <statement>
        <p permid="JyD">
          Explique en qué se diferencia la codificación de mensajes en <init>RSA</init> de la verificación de mensajes.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="kVT">
      <statement>
        <p permid="pFM">
          Explique cómo se podría justificar decir que la propuesta de Diffie y Hellman en 1976 era <q>revolucionaria</q>.
        </p>
      </statement>
      <response/>
    </exercise>

  </reading-questions>
    <!-- Exercises with Solutions  -->
    <!-- File: crypt.xml  -->
    <!-- Title: Introduction to Cryptography -->
  <exercises xml:id="crypt-exercises" filenamebase="crypt" permid="rHH">
    <title>Ejercicios</title>
  
    <exercise number="1" permid="oNb" xml:id="crypt-exercise-i-love-math">
      <statement>
        <p permid="Htv">Encripte <c>IXLOVEXMATH</c> usando el criptosistema del <xref ref="crypt-example-caesar"/>.
    </p>
      </statement>
      <hint permid="xbu">
        <p permid="hby"><c>LAORYHAPDWK</c></p>
      </hint>
      
    </exercise>
  
    <exercise number="2" permid="UUk" xml:id="crypt-exercise-ZLOOA-WKLVA-EHARQ-WKHA-ILQDO">
      <statement>
        <p permid="nAE">Decodifique <c>ZLOOA WKLVA EHARQ WKHA ILQDO</c>, que fue codificado usando el criptosistema del <xref ref="crypt-example-caesar"/>.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="3" permid="Bbt" xml:id="crypt-exercise-monoalphabetic-decode">
      <statement>
        <p permid="THN">Suponiendo que un código monoalfabético fue usado para codificar el siguiente mensaje secreto, ¿cuál era el mensaje original?</p>
        
        <pre>
        APHUO EGEHP PEXOV FKEUH CKVUE CHKVE APHUO
        EGEHU EXOVL EXDKT VGEFT EHFKE UHCKF TZEXO
        VEZDT TVKUE XOVKV ENOHK ZFTEH TEHKQ LEROF
        PVEHP PEXOV ERYKP GERYT GVKEG XDRTE RGAGA
        </pre>
  
        <p permid="zOW">¿Cuál es la importancia de este mensaje en la historia de la criptografía?</p>
      </statement>
      <hint permid="pwV">
        <p permid="NiH">Ayuda: <c>V = E</c>, <c>E = X</c> (también usado para espacios y puntuación), <c>K = R</c>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="4" permid="hiC" xml:id="crypt-exercise-total-possible-monoalphabetic">
      <statement>
        <p permid="fWf">¿Cuál es el número total de criptosistemas monoalfabéticos posibles? ¿Qué tan seguros son tales criptosistemas?</p>
      </statement>
      <hint permid="BLn">
        <p permid="tpQ"><m>26! - 1</m></p>
      </hint>
      
    </exercise>
  
    <exercise number="5" permid="NpL" xml:id="crypt-exercise-2-by-2-matrix-Z26">
      <statement>
        <p permid="Mdo">Demuestre que una matriz <m>A</m> de <m>2 \times 2</m> con coeficientes en <m>{\mathbb Z}_{26}</m> es invertible si y solo si <m>\gcd( \det(A), 26 ) = 1</m>.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="6" permid="twU" xml:id="crypt-exercise-matrix-encrypt">
      <statement>
        <p permid="skx">Dada la matriz 
          <me permid="Adr">A =
          \begin{pmatrix}
          3 &amp; 4 \\
          2 &amp; 3
          \end{pmatrix}</me>,
        use la función de encriptación <m>f({\mathbf p}) = A {\mathbf p} + {\mathbf b}</m> para encriptar el mensaje <c>CRYPTOLOGY</c>, donde <m>{\mathbf b} = ( 2, 5)^ \transpose</m>.  ¿Cuál es la función de decriptación?</p>
      </statement>
      
    </exercise>
  
    <exercise number="7" permid="ZEd" xml:id="crypt-exercise-RSA-encrypt">
      <statement>
        <p permid="YrG">Encripte cada uno de los siguientes mensajes <acro>RSA</acro>  <m>x</m> de manera que <m>x</m> se divida en bloques de enteros de longitud  <m>2</m>;  es decir, si <m>x = 142528</m>, entonces encripte <m>14</m>, <m>25</m>, y <m>28</m> por separado.
          <ol permid="UyL">
           
            <li permid="FpN"><p permid="mgQ"><m>n = 3551, E = 629, x = 31</m></p></li>
             
            <li permid="lwW"><p permid="SnZ"><m>n = 2257, E = 47, x = 23</m></p></li>
  
            <li permid="REf"><p permid="yvi"><m>n = 120979, E = 13251, x = 142371</m></p></li>
             
            <li permid="xLo"><p permid="eCr"><m>n = 45629, E = 781, x = 231561</m></p></li>
  
          </ol></p>
      </statement>
      <hint permid="anX">
        <p permid="ZwZ">(a) <m>2791</m>; (c) <m>112135 25032 442</m>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="8" permid="FLm" xml:id="crypt-exercise-RSA-decode-key">
      <statement>
        <p permid="EyP">Calcule la clave de decriptación <m>D</m> para cada una de las claves de encriptación en el <xref ref="crypt-exercise-RSA-encrypt"/>. 
        </p>
      </statement>
      
    </exercise>
  
    <exercise number="9" permid="lSv" xml:id="crypt-exercise-RSA-decrypt-examples">
      <statement>
        <p permid="kFY">Decripte cada uno de los siguientes mensajes <acro>RSA</acro>  <m>y</m>.
          <ol permid="AFU">
           
            <li permid="Cvh"><p permid="jmk"><m>n = 3551, D = 1997, y = 2791</m></p></li>
  
            <li permid="iCq"><p permid="Ptt"><m>n = 5893, D = 81, y = 34</m></p></li>
             
            <li permid="OJz"><p permid="vAC"><m>n = 120979, D = 27331, y = 112135</m></p></li>
             
            <li permid="uQI"><p permid="bHL"><m>n = 79403, D = 671, y = 129381</m></p></li>
           
          </ol></p>
      </statement>
      <hint permid="SJy">
        <p permid="FEi">(a) <m>31</m> (c) <m>14</m>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="10" permid="RZE" xml:id="crypt-exercise-compute-D">
      <statement>
        <p permid="QNh">Para cada una de las siguientes claves de encriptación <m>(n, E)</m> en el criptosistema <acro>RSA</acro>, calcule <m>D</m>.
          <ol permid="gNd">
       
            <li permid="zAB"><p permid="grE"><m>(n, E) = (451, 231)</m></p></li>
             
            <li permid="fHK"><p permid="MyN"><m>(n, E) = (3053, 1921)</m></p></li>
             
            <li permid="LOT"><p permid="sFW"><m>(n, E) = (37986733, 12371)</m></p></li>
             
            <li permid="rWc"><p permid="YNf"><m>(n, E) = (16394854313, 34578451)</m></p></li>
       
          </ol></p>
      </statement>
      <hint permid="eXQ">
        <p permid="lLr">(a) <m>n = 11 \cdot 41</m>; (c) <m>n = 8779 \cdot 4327</m>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="11" permid="ygN" xml:id="crypt-exercise-message-padding">
      <statement>
        <p permid="wUq">Los mensajes encriptados frecuentemente se dividen en bloques de <m>n</m> letras. Un mensaje como <c>THE WORLD WONDERS WHY</c> puede ser encriptado como <c>JIW OCFRJ LPOEVYQ IOC</c> pero enviado como <c>JIW OCF RJL POE VYQ IOC</c>.  ¿Cuáles son las ventajas de usar bloques de <m>n</m> letras?</p>
      </statement>
      
    </exercise>
  
    <exercise number="12" permid="enW" xml:id="crypt-exercise-X-hat-E-modn">
      <statement>
        <p permid="dbz">Encuentre enteros <m>n</m>, <m>E</m>, y <m>X</m> tales que
          <me permid="syS">X^E \equiv X \pmod{n}</me>.
        ¿Es este un potencial problema en el criptosistema <acro>RSA</acro>?</p>
      </statement>
      
    </exercise>
  
    <exercise number="13" permid="Kvf" xml:id="crypt-exercise-classroom-exercise">
      <statement>
        <p permid="JiI">Toda persona en el curso debiera construir un criptosistema <acro>RSA</acro> usando primos que tengan entre <m>10</m> y <m>15</m> dígitos.  Entregue  <m>(n, E)</m> y un mensaje encriptado. Mantenga el secreto de <m>D</m>. Vean si pueden romper los cifrados de los demás.
    </p>
      </statement>
      
    </exercise>
  
  </exercises>

  <exercises xml:id="crypt-exercises-additional" permid="XOQ">
    <title>Ejercicios Adicionales: Primalidad y Factorización</title>

    <p permid="nff">En el criptosistema <acro>RSA</acro> es importante ser capaz de encontrar números primos grandes con facilidad.  Asimismo, este criptosistema deja de ser seguro si somos capaces de factorizar un número entero que sea el producto de dos números primos grandes. Las soluciones teóricas de ambos problemas son bastante simples.  Para saber si un número <m>n</m> es primo o para factorizar <m>n</m>, podemos usar intentos de división. Simplemente dividimos <m>n</m> entre <m>d = 2, 3, \ldots, \sqrt{n}</m>. Ya sea obtendremos una factorización, o <m>n</m> es primo si ningún <m>d</m> divide a <m>n</m>.  El problema es que tales cálculos toman muchísimo tiempo si <m>n</m> es muy grande.
    </p>

    <exercise permid="WJx" xml:id="crypt-exercise-fermats-factorization-algorithm">
      <statement>
        <p permid="ppR">Un mejor algoritmo para factorizar enteros positivos impares es el <idx><h>Algoritmo de factorización de Fermat</h></idx><term>algoritmo de factorización de Fermat</term>.
    </p>

        <ol permid="MUm">
          <li permid="wFV"><p permid="dwY">Sea <m>n= ab</m> un número impar compuesto. Demuestre que <m>n</m> puede ser escrito como la diferencia de dos cuadrados perfectos:
            <me permid="YGb">n = x^2 - y^2 = (x - y)(x + y)</me>.
          Por lo tanto, un entero positivo impar se puede factorizar si y solo si podemos encontrar enteros <m>x</m> e <m>y</m> tales que <m>n = x^2 - y^2</m>.
    </p></li>
          <li permid="cNe"><p permid="JEh">Escriba un programa para implementar el siguiente algoritmo de factorización basado en la observación en la parte (a).  La expresión <c>ceiling(sqrt(n))</c> se refiere al menor entero que es mayor o igual a la raíz cuadrada de <m>n</m>. Escriba otro programa que use intentos de división y compare la velocidad de los dos algoritmos. ¿Cuál de ellos es más rápido y por qué?</p></li>
        </ol>

        <program permid="qCo">
          <input>
              x := ceiling(sqrt(n))
              y := 1

              1 : while x^2 - y^2 &gt; n do
                  y := y + 1

              if x^2 - y^2 &lt; n then
                  x := x + 1
                  y := 1
                  goto 1
              else if x^2 - y^2 = 0 then
                  a := x - y
                  b := x + y
                  write n = a * b
          </input>
      </program>

      </statement>
    </exercise>

    <exercise permid="CQG" xml:id="crypt-exercise-primality-testing">
      <title>Verificación de Primalidad</title>
      <statement>
        <p permid="Vxa">Recuerde el Pequeño Teorema de Fermat del Capí<xref ref="cosets"/>. Sea <m>p</m> un primo con <m>\gcd(a, p) = 1</m>. Entonces <m>a^{p-1} \equiv 1 \pmod{p}</m>.  Podemos usar el Pequeño Teorema de Fermat como un examen para primos. Por ejemplo, <m>15</m> no puede ser primo pues <me permid="ENk">2^{15-1} \equiv 2^{14} \equiv 4 \pmod{15}</me>. Pero, <m>17</m> es potencialmente un primo pues
          <me permid="kUt">2^{17-1} \equiv 2^{16} \equiv 1 \pmod{17}</me>.
        Decimos que un número compuesto impar <m>n</m> es un <term>pseudoprimo</term><idx><h>Pseudoprimo</h></idx> si 
          <me permid="RbC">2^{n-1} \equiv 1 \pmod{n}</me>.
        ¿Cuáles de los siguientes números son primos y cuáles son pseudoprimos?
        <ol cols="3" permid="tbv">
          <li permid="IUn">
            <p permid="pLq">
              <m>342</m>
            </p>
          </li>

          <li permid="pbw">
            <p permid="VSz">
              <m>811</m>
            </p>
          </li>

          <li permid="ViF">
            <p permid="BZI">
              601
            </p>
          </li>

          <li permid="BpO">
            <p permid="igR">
              <m>561</m>
            </p>
          </li>

          <li permid="hwX">
            <p permid="Ooa">
              <m>771</m>
            </p>
          </li>

          <li permid="NEg">
            <p permid="uvj">
              <m>631</m>
            </p>
          </li>
        </ol>
      </p>
      </statement>
    </exercise>

    <exercise permid="iXP" xml:id="crypt-exercise-pseudoprime">
      <statement>
        <p permid="BEj">Sea <m>n</m> un número impar compuesto y <m>b</m> un entero positivo tal que <m>\gcd(b, n) = 1</m>. Si <m>b^{n-1} \equiv 1 \pmod{n}</m>, entonces <m>n</m> es un <term>pseudoprimo en base</term> <m>b</m>. Muestre que <m>341</m> es un pseudoprimo en base <m>2</m> pero no es un  pseudoprimo en base <m>3</m>.
    </p>
      </statement>
    </exercise>

    <exercise permid="PeY" xml:id="crypt-exercise-primes-less-than-2000">
      <statement>
        <p permid="hLs">Escriba un programa para determinar todos los primos menores a <m>2000</m> usando intentos de división. Escriba un segundo programa que determine todos los números menores a <m>2000</m> que sean primos o pseudoprimos. Compare la velocidad de ambos programas.  ¿Cuántos pseudoprimos hay menores a <m>2000</m>?</p>
 
        <p permid="NSB">Existen números compuestos que son pseudoprimos para todas la bases con que son relativamente primos.  Estos números se llaman <idx><h>Números de Carmichael</h></idx><term>números de Carmichael</term>. El primer número de Carmichael es el <m>561 = 3 \cdot 11 \cdot 17</m>.  En 1992, Alford, Granville, y Pomerance demostraron que hay infinitos números de Carmichael [4].  Pero, los números de Carmichael son muy escasos.  Existen solo 2163 números de Carmichael menores a <m>25 \times 10^9</m>. Para tests de primalidad más sofisticados, vea [1], [6], o [7].
    </p>
      </statement>
    </exercise>
  </exercises>
 
  <references xml:id="crypt-references" permid="hbc">
    <title>Referencias y Lecturas Recomendadas</title>

    <biblio type="raw" permid="Nil"> <!-- was [1] -->
    Bressoud, D. M. <title>Factorization and Primality Testing</title>. Springer-Verlag, New York, 1989.
    </biblio>

    <biblio type="raw" permid="tpu"> <!-- was [2] -->
    Diffie, W. and Hellman, M. E. <q>New Directions in Cryptography,</q> <title>IEEE Trans. Inform. Theory</title> <volume> 22</volume> (1976), 644<ndash/>54.
    </biblio>

    <!-- Title corrected.  Suggested by R. Beezer.  TWJ - 12/20/2011 -->
    <biblio type="raw" permid="ZwD"> <!-- was [3] -->
    Gardner, M. <q>Mathematical games: A new kind of cipher that would take millions of years to break,</q> <title>Scientific American</title> <volume>237</volume> (1977), 120<ndash/>24.
    </biblio>

    <biblio type="raw" permid="FDM"> <!-- was [4] -->
    Granville, A. <q>Primality Testing and Carmichael Numbers,</q> <title>Notices of the American Mathematical Society</title> <volume>39</volume>(1992), 696<ndash/>700.
    </biblio>

    <biblio type="raw" permid="lKV"> <!-- was [5] -->
    Hellman, M. E. <q>The Mathematics of Public Key Cryptography,</q>  <title>Scientific American</title> <volume>241</volume>(1979), 130<ndash/>39.
    </biblio>

    <!-- reference updated - TWJ 5/10/2010 -->
    <biblio type="raw" permid="RSe"> <!-- was [6] -->
    Koblitz, N. <title>A Course in Number Theory and Cryptography</title>. 2nd ed. Springer, New York, 1994.
    </biblio>

    <biblio type="raw" permid="xZn"> <!-- was [7] -->
    Pomerance, C., ed. <q>Cryptology and Computational Number Theory</q>, <title>Proceedings of Symposia in Applied Mathematics</title> <volume>42</volume>(1990) American Mathematical Society, Providence, RI.
    </biblio>

    <biblio type="raw" permid="egw"> <!-- was [8] -->
    Rivest, R. L., Shamir, A., and Adleman, L., <q>A Method for Obtaining Signatures and Public-key Criptosistemas,</q> <title>Comm. ACM</title> <volume>21</volume>(1978), 120<ndash/>26.
    </biblio>

  </references>

  <section xml:id="crypt-sage" component="sage-info" permid="cyJ">
    <title>Sage</title>
  
    <introduction permid="kNc">
      <p permid="bmm">Debido a que Sage comenzó como software para el apoyo de la investigación en teoría de números, podemos rápida y fácilmente mostrar los mecanismos internos por los que funciona el algoritmo <acro>RSA</acro>.  Reconozcamos que, en la práctica, muchos otros detalles tales como la codificación entre letras y enteros, o la protección de la clave privada, son igualmente importantes para proteger la seguridad de la comunicación.  <acro>RSA</acro> por sí mismo es solo un fundamento teórico.
    </p>
    </introduction>
  
    <subsection permid="TeX">
      <title>Construyendo claves</title>
  
      <p permid="MNi">Supondremos que Alice quiere enviar un mensaje secreto a Bob, junto con un mensaje de verificación (también conocido como firma digital).  Comenzaremos con la construcción de un par de claves (privada y pública) para Alice y para Bob.  Primero necesitamos dos primos grandes y su producto para cada uno de ellos.  En la práctica, los valores de <m>n</m> tendrían cientos de dígitos, en lugar de solo <m>21</m> como hemos hecho acá.
    </p>
  
      <sage permid="SZT">
        <input>
        p_a = next_prime(10^10)
        q_a = next_prime(p_a)
        p_b = next_prime((3/2)*10^10)
        q_b = next_prime(p_b)
        n_a = p_a * q_a
        n_b = p_b * q_b
        n_a, n_b
        </input>
        <output>(100000000520000000627, 225000000300000000091)</output>
      </sage>
  
      <p permid="sUr">Computacionalmente, el valor de la función <m>\phi</m> de Euler del producto de dos primos <m>pq</m> puede ser obtenida como <m>(p-1)(q-1)</m>, pero podemos igualmente usar la función interna de Sage.
    </p>
  
      <sage permid="zhc">
        <input>
        m_a = euler_phi(n_a)
        m_b = euler_phi(n_b)
        m_a, m_b
        </input>
        <output>(100000000500000000576, 225000000270000000072)</output>
      </sage>
  
      <p permid="ZbA">Ahora podemos crear los exponentes de encriptación y decriptación.  Elegimos el exponente de encriptación como un número (pequeño) relativamente primo con el valor de <m>m</m>.  Con Sage podemos factorizar <m>m</m> rápidamente para elegir este valor.  En la práctica no querremos hacer este cálculo para valores grandes de <m>m</m>, así es que podemos más fácilmente elegir valores <q>aleatorios</q> y verificar hasta el primer valor relativamente primo con <m>m</m>.  El exponente de decriptación es el inverso multiplicativo, mód <m>m</m>, del exponente de encriptación.  Si construye un exponente de encriptación inadecuado (no relativamente primo con <m>m</m>), fallará el cálculo de este inverso multiplicativo (y Sage se lo dirá).  Hacemos esto dos veces <mdash/> para Alice y para Bob.
    </p>
  
      <sage permid="fol">
      <input>factor(m_a)</input>
      <output>2^6 * 3 * 11 * 17 * 131 * 521 * 73259 * 557041</output>
      </sage>
  
      <sage permid="Lvu">
      <input>
      E_a = 5*23
      D_a = inverse_mod(E_a, m_a)
      D_a
      </input>
      <output>20869565321739130555</output>
      </sage>
  
      <sage permid="rCD">
        <input>factor(m_b)</input>
        <output>2^3 * 3^4 * 107 * 1298027 * 2500000001</output>
      </sage>
  
      <sage permid="XJM">
        <input>
        E_b = 7*29
        D_b = inverse_mod(E_b, m_b)
        D_b
        </input>
        <output>24384236482463054195</output>
      </sage>
  
      <p permid="FiJ">En esta etapa, cada individuo publicaría sus valores de <m>n</m> y <m>E</m>, guardando <m>D</m> en forma privada y segura.  En la práctica <m>D</m> debiese estar protegido en el disco duro del usuario por una clave que solo conozca el dueño.  Para aún mayor seguridad, una persona podría tener solo dos copias de su clave privada, una en un pituto de memoria <acro>USB</acro> que siempre lleve consigo, y una copia de respaldo en su caja de seguridad en Sage.  Cada vez que la persona use <m>D</m> deberá indicar su clave.  El valor de  <m>m</m> puede ser desechado.  Para el registro, acá están todas las claves:</p>
  
      <sage permid="DQV">
        <input>print("Alice's public key, n:", n_a, "E:", E_a)</input>
        <output>Alice's public key, n: 100000000520000000627 E: 115</output>
      </sage>
  
      <sage permid="jYe">
        <input>print("Alice's private key, D:", D_a)</input>
        <output>Alice's private key, D: 20869565321739130555</output>
      </sage>
  
      <sage permid="Qfn">
        <input>print("Bob's public key, n:", n_b, "E:", E_b)</input>
        <output>Bob's public key, n: 225000000300000000091 E: 203</output>
      </sage>
  
      <sage permid="wmw">
        <input>print("Bob's private key, D:", D_b)</input>
        <output>Bob's private key, D: 24384236482463054195</output>
      </sage>
  
      <sage type="practice"/>
  
    </subsection>
  
    <subsection permid="zmg">
      <title>Firmando y Encriptando un Mensaje</title>
  
      <p permid="lpS">Alice construirá un mensaje que consiste de una palabra de cuatro letras en inglés.  A partir de estas cuatro letras construiremos un número que represente el mensaje en la forma que necesitamos para usar en el algoritmo  <acro>RSA</acro>.  La función <c>ord()</c> convertirá una letra en su valor <acro>ASCII</acro>, un número entre 0 y 127.  Si usamos estos números como <q>dígitos</q> mód 128, podemos estar seguros que la palabra de cuatro letras de Alice se codificará como un entero menor a <m>128^4=268,435,456</m>.  El valor particular no tiene importancia, mientras sea menor que el valor de nuestro <m>n</m> pues toda la aritmética que sigue es mód <m>n</m>.  Elegimos una palabra popular de cuatro letras, la convertimos en <q>dígitos</q> <acro>ASCII</acro> con una lista, y construimos el entero a partir de los dígitos en la base correcta.  Note como podemos tratar la palabra como una lista y que el primer dígito en la lista está en el lugar de las <q>unidades</q> (decimos que la lista está en orden <q>little-endian</q>)..
    </p>
  
      <sage permid="ctF">
        <input>
        word = 'Sage'
        digits = [ord(letter) for letter in word]
        digits
        </input>
        <output>[83, 97, 103, 101]</output>
      </sage>
  
      <sage permid="IAO">
        <input>
        message = ZZ(digits, 128)
        message
        </input>
        <output>213512403</output>
      </sage>
  
      <p permid="Rxb">Primero, Alice firmará su mensaje para proveer una verificación.  Para eso usa su clave privada, pues esto es algo que solo ella debiese poder hacer.
    </p>
  
      <sage permid="oHX">
        <input>
        signed = power_mod(message, D_a, n_a)
        signed
        </input>
        <output>47838774644892618423</output>
      </sage>
  
      <p permid="xEk">Luego Alice encripta el mensaje de manera que solo Bob lo pueda leer.  Para esto usa la clave pública de Bob.  Note que no es siquiera necesario que conozca a Bob <mdash/> por ejemplo, ella podría haber obtenido la clave pública de Bob en su página web o quizás Bob la publicó en el <pubtitle>New York Times</pubtitle>.
    </p>
  
      <sage permid="UPg">
        <input>
        encrypted = power_mod(signed, E_b, n_b)
        encrypted
        </input>
        <output>111866209291209840488</output>
      </sage>
  
      <p permid="dLt">La comunicación de Alice está lista para ser transmitida por cualquier red, no importando lo insegura que pueda ser y no importando cuánta gente pueda estar vigilándola.
    </p>
  
      <sage type="practice"/>
  
      </subsection>
  
      <subsection permid="ftp">
      <title>Decriptación y Verificación del Mensaje</title>
  
      <p permid="JSC">Ahora supongamos que el valor de <c>encrypted</c> a llegado a Bob.  Bob podría no conocer a Alice ni necesariamente creer que ha recibido un mensaje genuinamente enviado por ella.  Un adversario podría estar tratando de confundir a Bob enviándole mensajes supuestamente provenientes de Alice.  Primero, Bob debe deshacer la encriptación hecha por Alice.  Esto es algo que solo Bob, como el receptor intencionado, debiese ser capaz de realizar.  Y lo hace usando su clave privada, que solo él conoce, y que ha mantenido segura.
    </p>
  
      <sage permid="AWp">
        <input>
        decrypted = power_mod(encrypted, D_b, n_b)
        decrypted
        </input>
        <output>47838774644892618423</output>
      </sage>
  
      <p permid="pZL">En este momento, el mensaje no tiene gran significado para Bob.  Cualquiera podría haberle enviado un mensaje encriptado.  Pero, este era un mensaje firmado por Alice.  Deshagamos ahora la firma.  Notemos que esto requiere la clave pública de Alice.  Bob no necesita conocer a Alice <mdash/> por ejemplo podría obtener la clave pública de Alice de su página web o quizás Alice la publicó en el <pubtitle>New York Times</pubtitle>.
    </p>
  
      <sage permid="hdy">
        <input>
        received = power_mod(decrypted, E_a, n_a)
        received
        </input>
        <output>213512403</output>
      </sage>
  
      <p permid="WgU">Bob necesita transformar esta representación entera de vuelta a una palabra con letras.  La función <c>chr()</c> convierte valores <acro>ASCII</acro> en letras, y usamos una lista para hacer esto en forma repetida.
    </p>
  
      <sage permid="NkH">
        <input>
        digits = received.digits(base=128)
        letters = [chr(ascii) for ascii in digits]
        letters
        </input>
        <output>['S', 'a', 'g', 'e']</output>
      </sage>
  
      <p permid="Cod">Si queremos un resultado más legible, podemos combinar estas letras en una cadena.
    </p>
  
      <sage permid="trQ">
        <input>''.join(letters)</input>
        <output>'Sage'</output>
      </sage>
  
      <p permid="ivm">Bob está contento de haber recibido un mensaje tan interesante de Alice.  ¿Qué habría sucedido si un impostor hubiese enviado un mensaje pretendiendo ser de Alice, o si un adversario hubiese interceptado y adulterado el mensaje original de Alice?  (Lo segundo es lo que se conoce como un ataque de <q>hombre en el medio</q>.)</p>
  
      <p permid="OCv">En cualquiera de estos casos, el tercero no sería capaz de duplicar la primera acción de Alice <mdash/> firmar su mensaje.  Si un adversario firma de alguna manera el mensaje, o lo altera en cualquier forma, el resultado cuando Bob deshaga la firma producirá pura basura.  (Inténtelo!)  Como Bob recibió una palabra legítima, con la mayúscula apropiada, puede confiar en que el mensaje que obtuvo es el mismo que fue firmado por Alice.  En la práctica, si Alice envía varios cientos de palabras en su mensaje, la probabilidad de obtener un texto coherente a partir de un mensaje adulterado, es astronómicamente pequeña.
    </p>
  
      <p permid="uJE">¿Qué hemos mostrado?</p>
  
      <ol permid="ZiE">
        <li permid="tLp"><p permid="aCs">Alice puede enviar mensajes que solo Bob puede leer.
    </p></li>
  
        <li permid="ZSy"><p permid="GJB">Bob puede recibir mensajes secretos de cualquiera.
    </p></li>
  
        <li permid="FZH"><p permid="mQK">Alice puede firmar mensajes, de manera que Bob sabe que provienen genuinamente de Alice.
    </p></li>
      </ol>
  
      <p permid="aQN">Por supuesto, sin hacer nuevas claves, se pueden intercambiar los roles de Alice y Bob.  Y si Carol crea un par de claves, ella se puede comunicar tanto con Alice como con Bob de la misma forma.
    </p>
  
      <p permid="GXW">Si usted desea usar encriptación <acro>RSA</acro> de clave pública seriamente, investigue el software GNU Privacy Guard, aka <c>GPG</c>, que está libremente disponible en <url href="https://www.gnupg.org/" visual="www.gnupg.org">www.gnupg.org/</url>.  Notemos que solo tiene sentido usar programas de encriptación que le permitan conocer el código fuente.
    </p>
  
      <sage type="practice"/>
  
    </subsection>
  
  </section>
  <exercises xml:id="crypt-sage-exercises" component="sage-exercises" permid="DVZ">
    <title>Ejercicios en Sage</title>
  
    <exercise number="1" permid="vmh" xml:id="crypt-sage-exercise-key-pair-alice">
      <statement>
        <p permid="tZK">Construya un par de claves para Alice usando los primeros dos primos mayores a <m>10^{12}</m>.  Para su elección de <m>E</m>, use un primo y use el menor posible.
    </p>
  
        <p permid="agT">Obtenga los valores de <m>n</m>, <m>E</m>, y <m>D</m> para Alice.  Luego use comandos de Sage para verificar que las claves de encriptación y decriptación de Alice son inversos multiplicativos.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="2" permid="btq" xml:id="crypt-sage-exercise-key-pair-bob">
      <statement>
        <p permid="Goc">Construya un par de claves para Bob usando los primeros dos primos mayores a <m>2\cdot 10^{12}</m>.  Para su elección de <m>E</m>, use un primo y use el menor posible.  Obtenga los valores de <m>n</m>, <m>E</m>, y <m>D</m> para Alice. </p>
  
        <p permid="mvl">Codifique la palabra <c>Math</c> usando valores <acro>ASCII</acro> de la forma descrita en esta sección (mantenga las mayúsculas como se muestran).  Cree un mensaje firmado de esta palabra para una comunicación de Alice a Bob.  Obtenga los tres enteros: el mensaje, el mensaje firmado, y el mensaje firmado, encriptado.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="3" permid="HAz" xml:id="crypt-sage-exercise-bob-decrypt">
      <statement>
        <p permid="SCu">Muestre como Bob transformaría el mensaje recibido de Alice de vuelta a la palabra <c>Math</c>.  Obtenga tanto los valores intermedios como el resultado final.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="4" permid="nHI" xml:id="crypt-sage-exercise-signing-message">
      <statement>
        <p permid="yJD">Cree un nuevo mensaje firmado de Alice para Bob.  Simule una adulteración del mensaje sumando <m>1</m> al entero recibido por Bob, antes que el lo decripte.  ¿Qué resultado obtiene Bob para las letras del mensaje cuando decripta y de-firma el mensaje adulterado?</p>
      </statement>
      
    </exercise>
  
    <exercise number="5" permid="TOR" xml:id="crypt-sage-exercise-classroom">
      <title>Ejercicio para la Sala de Clases</title>
      <statement>
        <p permid="eQM">Organice el curso en grupos pequeños.  Haga que cada grupo construya un par de claves con algún tamaño mínimo (dígitos en <m>n</m>).  Cada grupo debiese guardar su clave privada en secreto, pero dejar disponible para todo el curso su clave pública.  Podría ser escrita en la pizarra o pegada en un lugar público como <url href="http://pastebin.com/" visual="pastebin.com"><c>pastebin.com</c></url>.  Luego cada grupo puede enviar un mensaje a otro grupo, donde los grupos podrían estar organizados lógicamente en un círculo para este propósito.  Por supueso, los mensajes se deben transmitir públicamente también.  Espere una tasa de éxito entre el 50% y el 100%.
    </p>
  
        <p permid="KXV">Si no hace esto en clase, consiga un compañero de estudios e intercambie mensajes de la misma forma.
    </p>
      </statement>
    </exercise>
  
  </exercises>
  

</chapter>
