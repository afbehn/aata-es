<?xml version='1.0' encoding='UTF-8'?>
<!-- This file is part of the book                    -->
<!--                                                  -->
<!-- Abstract Algebra: Theory and Applications        -->
<!--                                                  -->
<!-- Text: Copyright (C) 1997-2023  Thomas W. Judson  -->
<!-- Sage: Copyright (C) 2010-2023  Robert A. Beezer  -->
<!-- See the file COPYING for copying conditions.     -->
<!-- This file is part of the book                    -->
<!--                                                  -->
<!-- See the file COPYING for copying conditions.     -->
<chapter xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="algcodes" permid="jTr">
  <title>Teoría Algebraica de Códigos</title>

  <introduction permid="rMl">
    <p permid="cYZ">La teoría de códigos es una aplicación del álgebra que se ha vuelto cada vez más importante durante las últimas décadas. Cuando transmitimos datos, estamos preocupados de transmitir datos a través de un canal que podría estar afectado por <q>ruido</q>. Queremos ser capaces de codificar y decodificar la información de forma de poder detectar, y posiblemente corregir, los errores causados por el ruido. Esta situación surge en muchas áreas de comunicación, incluyendo la radio, telefonía, televisión, comunicaciones entre computadores, y tecnologías de almacenamiento digital. Probabilidades, combinatoria, teoría de grupos, álgebra lineal y anillos de polinomios sobre cuerpos finitos todos tienen un rol importante en la teoría de códigos. </p>
  </introduction>
 
  <section xml:id="algcodes-section-error-detecting-correcting-codes" permid="lIE">
    <title>Códigos para Detectar y para Corregir Errores</title>

    <introduction permid="XTu">

      <p permid="Jgi">Consideremos un modelo simple de sistema de comunicaciones para el envío y recepción de mensajes codificados (ver la <xref ref="algcodes-figure-encoding"/>).
      </p>  

      <figure xml:id="algcodes-figure-encoding" permid="BBJ">
        
        <caption>Codificación y decodificación de mensajes</caption>
            <!-- Replaced figure with tikz figure - TWJ 5/10/2010 -->
        <image width="60%" xml:id="algcodes-encode-decode" permid="Qie">
          <description>Un diagrama de flujo vertical donde un mensaje de m dígitos se pasa a un codificador que está representado por un rectángulo para convertirse en una palabra clave de n dígitos que se pasa a un transmisor que también está representado por un rectángulo. El resultado del transmisor puede tener ruido y se pasa al receptor que está representado por un rectángulo. El receptor pasa una palabra recibida de n dígitos a un decodificador que está representado por un rectángulo. El decodificador produce una palabra recibida de m dígitos o un error.</description>
            <latex-image>
                <xi:include href="tikz/algcodes-encode-decode.tex" parse="text"/>
            </latex-image>
        </image>

      </figure>

      <p permid="pnr">Mensajes sin codificar pueden estar compuestos de letras o caracteres, pero típicamente consisten de <m>m</m>-tuplas binarias. Estos mensajes se codifican en palabras de un código, que son <m>n</m>-tuplas binarias, a través de un mecanismo llamado <term>codificador</term>. El mensaje es transmitido y luego decodificado. Consideraremos la aparición de errores durante la transmisión. Un <term>error</term> occure si hay un cambio en uno o más bits de la palabra del código. Un <term>protocolo decodificador</term> es un método que ya sea convierte  <m>n</m>-tupla arbitraria recibida en un mensaje decodificado coherente o da un mensaje de error para esa <m>n</m>-tupla. Si el mensaje recibido es una palabra del código (una de las <m>n</m>-tuplas permitidas), entonces el mensaje decodificado debe ser el mensaje que fue codificado en la palabra del código. Para tuplas recibidas que no están en el código, el protocolo dará una indicación de error, o, si somos más astutos, tratará de corregir el error y reconstruir el mensaje original. Nuestro objetivos es transmitir mensajes libres de errores de la forma más barata y rápida posible.
      </p>
 
 
      <example xml:id="algcodes-example-repeat" permid="isz">
        <p permid="lIR">Un posible mecanismo de codificación sería enviar el mensaje múltiples veces y comparar las copias recibidas entre ellas. Supongamos que el mensaje a codificar es una <m>n</m>-tupla binaria <m>(x_{1}, x_{2}, \ldots, x_{n})</m>. El mensaje se codifica en una <m>3n</m>-tupla binaria simplemente repitiendo el mensaje tres veces: 
          <me permid="pBM">(x_{1}, x_{2}, \ldots, x_{n}) \mapsto (x_{1}, x_{2}, \ldots, x_{n}, x_{1}, x_{2}, \ldots, x_{n}, x_{1}, x_{2}, \ldots, x_{n})</me>.
        Para decodificar el mensaje, escogemos como el <m>i</m>-ésimo dígito el que aparezca en la <m>i</m>-ésima posición de al menos dos de las tres transmisiones. Por ejemplo, si el mensaje original es <m>(0110)</m>, entonces el mensaje transmitido será <m>(0110\;  0110\;  0110)</m>. Si hay un error de transmisión en el quinto dígito, entonces la palabra recibida será <m>(0110\;  1110\;  0110)</m>, la que será correctamente decodificada como <m>(0110)</m>.<fn>Adoptaremos la convención de numerar los dígitos de izquierda a derecha en las <m>n</m>-tuplas binarias.
        </fn>  Este método de repetición-triple automáticamente detecta y corrige todos los errores individuales, pero es lento e ineficiente: para enviar un mensaje que consista de <m>n</m> bits, se requieren <m>2n</m> bits adicionales, y solo podemos detectar y corregir errores individuales. Veremos que es posible encontrar mecanismos de codificación que codifiquen un mensaje de <m>n</m> bits en uno de <m>m</m> bits con <m>m</m> mucho menor a <m>3n</m>.
      </p>
      </example>
 
       <example xml:id="algcodes-example-even-parity" permid="OzI">
        <p permid="RQa"><term>La paridad</term>, un mecanismo de codificación usual, es mucho más eficiente que la simple repetición. El código <acro>ASCII</acro> (American Standard Code for Information Interchange) usa <m>8</m>-tuplas binarias, dando lugar a <m>2^{8} = 256</m> <m>8</m>-tuplas posibles. Pero, solo se necesitan siete bits pues solo hay <m>2^7 = 128</m> caracteres <acro>ASCII</acro>. ¿Qué se puede o debe hacer con el bit restante? Usando los ocho dígitos, podemos detectar un error individual de transmisión. Por ejemplo, los códigos <acro>ASCII</acro> para A, B, y C son 
          <md permid="VIV">
            <mrow>\text{A} &amp; = 65_{10} = 01000001_{2},</mrow>
            <mrow>\text{B} &amp; = 66_{10} = 01000010_{2},</mrow>
            <mrow>\text{C} &amp; = 67_{10} = 01000011_{2}</mrow>
          </md>.
        Note que el bit de más a la izquierda siempre es 0; es decir, los <m>128</m> caracteres <acro>ASCII</acro> tienen códigos 
          <md permid="BQe">
            <mrow>00000000_{2} &amp; = 0_{10},</mrow>
            <mrow>&amp; \vdots</mrow>
            <mrow>01111111_{2} &amp; = 127_{10}</mrow>
          </md>.
        El bit puede ser usado para controlar errores en los otros siete bits. Se pone como <m>0</m> o <m>1</m> de manera que el número total de bits <m>1</m> en la representación del caracter sea par. Usando paridad, los códigos para A, B, y C se convierten en
          <md permid="hXn">
            <mrow>\text{A} &amp; = 01000001_{2},</mrow>
            <mrow>\text{B} &amp; = 01000010_{2},</mrow>
            <mrow>\text{C} &amp; = 11000011_{2}</mrow>
          </md>.
        Supongamos que se envía una A y ocurre un error de transmisión en el sexto bit de manera que se recibe <m>(0100\; 0101)</m>. Sabemos que se produjo un error pues se recibió un número impar de <m>1</m>s, y podemos pedir que la palabra sea retransmitida. Cuando se usa para detectar errores, el bit de más a la izquierda se llama <term>bit de control de paridad</term>.
      </p> 
 
 
        <p permid="xXj">Por lejos el mecanismo más común de detección de errores en los computadores está basado en la adición de un bit de paridad. Típicamente, un computador guarda la información en <m>m</m>-tuplas llamadas <term>palabras</term>. Largos comunes para las palabras son <m>8</m>,
          <m>16</m>, y <m>32</m> bits. Un bit en la palabra se reserva como bit de control de paridad, y no se usa para almacenar información. Este bit se pone como <m>0</m> o <m>1</m>, dependiendo del número de <m>1</m>s de la palabra.
      </p> 
 
        <p permid="ees">Agregar un control de paridad permite la detección de todos los errores únicos pues cualquier cambio a un solo bit, ya sea aumenta o disminuye en uno el número de <m>1</m>s, y en cualquier caso cambia la paridad de par a impar, de manera que la nueva palabra no es una palabra del código.
        (También podríamos construir un esquema de detección de errores basado en <term>paridad impar</term>; es decir, podríamos configurar el bit de verificación de paridad para que una palabra clave siempre tenga un número impar de <m>1</m>s.)</p>
      </example>
   
      <p permid="VuA">El sistema de paridad es fácil de implementar, pero tiene dos desventajas.  En primer lugar, errores múltiples no son detectables. Supongamos que se envía una A y los bits primero y séptimo se cambian de <m>0</m> a <m>1</m>. La palabra recibida resulta ser una palabra del código, pero será decodificada como una C en lugar de una A. En segundo lugar, no tenemos la habilidad de corregir errores.  Si la 8-tupla <m>(1001\; 1000)</m> es recibida, sabemos que ha ocurrido un error, pero no tenemos idea cuál es el bit que se ha cambiado. Investigaremos ahora un mecanismo de codificación que no solo nos permita detectar errores de transmisión, sino que nos permita corregirlos.
      </p> 

      <example xml:id="algcodes-example-nearest" permid="uGR">
        <p permid="KlB">
          Supongamos que nuestro mensaje original es un <m>0</m> o un <m>1</m>, y que <m>0</m> se codifica como <m>(000)</m> y <m>1</m> se codifica como <m>(111)</m>.
Si solo ocurre un error durante la transmisión, podemos detectar y corregir el error.
Por ejemplo, si se recibe un <m>(101)</m>, el segundo bit debe haberse cambiado de <m>1</m> a <m>0</m>.
La palabra clave transmitida originalmente debe haber sido <m>(111)</m>.
Este método detectará y corregirá todos los errores individuales.
        </p>

        <table xml:id="algcodes-table-repetition-code" permid="cww">
          <title>A repetition code</title>
          <tabular halign="center" top="medium" permid="IDF">
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <row>
              <cell>Transmitted</cell>
              <cell colspan="8">Received Word</cell>
            </row>
            <row bottom="medium">
              <cell>Codeword</cell>
              <cell><m>000</m></cell>
              <cell><m>001</m></cell>
              <cell><m>010</m></cell>
              <cell><m>011</m></cell>
              <cell><m>100</m></cell>
              <cell><m>101</m></cell>
              <cell><m>110</m></cell>
              <cell><m>111</m></cell>
            </row>
            <row>
              <cell><m>000</m></cell>
              <cell><m>0</m></cell>
              <cell><m>1</m></cell>
              <cell><m>1</m></cell>
              <cell><m>2</m></cell>
              <cell><m>1</m></cell>
              <cell><m>2</m></cell>
              <cell><m>2</m></cell>
              <cell><m>3</m></cell>
            </row>
            <row bottom="medium">
              <cell><m>111</m></cell>
              <cell><m>3</m></cell>
              <cell><m>2</m></cell>
              <cell><m>2</m></cell>
              <cell><m>1</m></cell>
              <cell><m>2</m></cell>
              <cell><m>1</m></cell>
              <cell><m>1</m></cell>
              <cell><m>0</m></cell>
            </row>
          </tabular>

        </table>

        <p permid="qsK">
          En <xref ref="algcodes-table-repetition-code"/>, presentamos todas las palabras posibles que podrían recibirse para las palabras clave transmitidas <m>(000)</m> y <m>(111)</m>.
<xref ref="algcodes-table-repetition-code"/> también muestra el número de bits en los que cada tupla <m>3</m> recibida difiere de cada palabra de código original.
        </p>
      </example>
   
    </introduction>

    <subsection xml:id="algcodes-subsection-max-likelihood" permid="QaA">
      <title>Decodificación de Probabilidad Máxima</title>

<!-- Label repaired.  Suggested by R. Beezer. -->
<!-- TWJ - 12/19/2011 -->

      <p permid="fyg">El mecanismo de codificación presentado en el <xref ref="algcodes-example-nearest"/> no es una solución completa del problema pues no toma en cuenta la posibilidad de múltiples errores. Por ejemplo, ya sea un (000) o un (111) se podría enviar y se podría recibir un (001). No tenemos forma de decidir a partir de la palabra recibida si se cometió un solo error en el tercer bit o dos errores, uno en el primer bit y uno en el segundo.  Sin importar el mecanismo de codificación usado, un mensaje incorrecto puede ser recibido. Podríamos transmitir un (000), tener errores en los tres bits, y recibir la palabra (111) del código. Es importante explicitar las suposiciones hechas sobre la probabilidad y distribución de los errores de transmisión de manera que, en una aplicación particular, se sabrá si un cierto mecanismo de detección de errores es apropiado. Supondremos que los errores de transmisión son infrecuentes, y, que cuando ocurren, ocurren de forma independiente en cada bit; es decir, si <m>p</m> es la probabilidad de un error en un bit y <m>q</m> es la probabilidad de error en otro bit, entonces la probabilidad de errores en ambos bits al mismo tiempo, es <m>pq</m>. También supondremos que una <m>n</m>-tupla recibida se decodificará en la palabra del código que esté más cerca; es decir, suponemos que el receptor usa <idx><h>Decodificación de probabilidad máxima</h></idx><term>decodificación de probabilidad máxima</term>.<fn>Esta sección requiere conocimientos de probabilidad, pero puede saltarse sin pérdida de continuidad.
      </fn></p>
 
      <figure xml:id="algcodes-figure-channel" permid="rMy">
        
        <caption>Canal simétrico binario</caption>
            <!-- Replaced figure with tikz figure - TWJ 5/10/2010 -->
        <image width="40%" xml:id="algcodes-binary-channel" permid="wpn">
          <description>Un diagrama esquemático donde un cero tiene probabilidad p de que se decodifique como cero y probabilidad q de que se decodifique como uno, que se representan con flechas de 0 a 0 y de 1 a 1, respectivamente. Un uno tiene probabilidad p de que sea decodificado como uno y probabilidad q de que sea decodificado como cero, las cuales están representadas por flechas de 1 a 1 y de 0 a 1, respectivamente.</description>
            <latex-image>
                <xi:include href="tikz/algcodes-binary-channel.tex" parse="text"/>
            </latex-image>
        </image>

      </figure>

      <p permid="LFp">Un <term>  canal simétrico binario</term><idx><h>  canal simétrico binario</h></idx> es un modelo que consiste de un transmisor capaz de enviar una señal binaria, ya sea un <m>0</m> o un <m>1</m>, junto a un receptor. Sea <m>p</m> la probabilidad de que la señal se recibe correctamente. Entonces <m>q = 1 - p</m> es la probabilidad de recepción incorrecta. Si se envía un <m>1</m>, entonces la probabilidad de recibir un <m>1</m> es <m>p</m> y la probabilidad de recibir un <m>0</m> es <m>q</m> (<xref ref="algcodes-figure-channel"/>). La probabilidad de que no ocurra ningún error durante la transmisión de una palabra binaria del código de largo <m>n</m> es <m>p^{n}</m>. Por ejemplo, si <m>p=0.999</m> y se envía un mensaje consistente de 10,000 bits, entonces la probabilidad de una transmisión perfecta es <me permid="Oew">(0.999)^{10,000} \approx 0.00005</me>,</p>
 
    <theorem permid="qsx">
      <statement>
        <p permid="LqU">Si una <m>n</m>-tupla binaria <m>(x_{1}, \ldots, x_{n})</m> es transmitida por un   canal simétrico binario con probabilidad <m>p</m> de que no ha ocurrido error en cada coordenada, entonces la probabilidad de que no haya errores en exactamente <m>k</m> coordenadas es <me permid="ulF">\binom{n}{k} q^kp^{n - k}</me>.
        </p>
      </statement>
      <proof permid="wwe">
        <p permid="duy">Fijemos <m>k</m> coordenadas diferentes. Calculemos primero la probabilidad de que un error ha ocurrido en este conjunto fijo de coordenadas. La probabilidad de que haya ocurrido un error en una en particular de estas <m>k</m> coordenadas es <m>q</m>; la probabilidad de que ningún error haya ocurrido en una de las restantes <m>n-k</m> coordenadas es <m>p</m>. La probabilidad de cada una de estos <m>n</m> eventos independientes es <m>q^{k}p^{n-k}</m>. El número posible de patrones de error con exactamente <m>k</m> errores es igual a 
          <me permid="asO">\binom{n}{k}  = \frac{n!}{k!(n - k)!}
          </me>,
        el número de combinaciones de <m>k</m> cosas elegidas entre un total de <m>n</m>. Cada uno de estos patrones de error tiene probabilidad <m>q^{k}p^{n-k}</m> de ocurrir; luego, la probabilidad de todos estos patrones de error es
          <me permid="GzX">\binom{n}{k}  q^{k}p^{n - k}
          </me>.
          </p>
      </proof>
    </theorem>
 
    <example xml:id="algcodes-example-probability" permid="WzG">
      <p permid="WzT">Supongamos que <m>p = 0.995</m> y que se envía un mensaje de <m>500</m>-bits. La probabilidad de que el mensaje haya sido enviado sin errores es 
        <me permid="mHg">p^{n} = (0.995)^{500} \approx 0.082</me>.
      La probabilidad de que ocurra exactamente un error es
        <me permid="SOp">\binom{n}{1}  qp^{n - 1}= 500(0.005)(0.995)^{499} \approx 0.204</me>.
      La probabilidad de exactamente dos errores es
        <me permid="yVy">\binom{n}{2} q^{2}p^{n - 2}= \frac{500 \cdot 499}{2}(0.005)^{2}(0.995)^{498} \approx 0.257</me>.
      La probabilidad de más de dos errores es aproximadamente
        <me permid="fcH">1 - 0.082 - 0.204 - 0.257 = 0.457</me>.
    </p>
    </example>
 
    </subsection>

    <subsection xml:id="algcodes-subsection-block-codes" permid="whJ">
      <title>Códigos de Bloque</title>
 
      <p permid="XTH">Si vamos a desarrollar códigos eficientes para detectar y corregir errores, necesitaremos herramientas matemáticas más sofisticadas.  La teoría de grupos permitirá métodos más rápidos y eficientes para codificar y decodificar mensajes. Un código es un  <term>código de bloque</term> <m>(n, m)</m> si la información que se codificará se puede dividir en bloques de <m>m</m> dígitos binarios, cada uno de los cuales puede ser codificado en <m>n</m> dígitos binarios. Más específicamente, un código de bloque <m>(n, m)</m> consiste de una <term>función codificadora</term> 
        <me permid="LjQ">E:{\mathbb Z}^{m}_{2} \rightarrow {\mathbb Z}^{n}_{2}</me>
      y una <term>función decodificadora</term>
        <me permid="rqZ">D:{\mathbb Z}^{n}_{2} \rightarrow {\mathbb Z}^{m}_{2}</me>.
      Una <term>palabra del código</term> es cualquier elemento en la imagen de <m>E</m>. También requerimos que <m>E</m> sea uno a uno de manera que dos bloques de información no sean codificados en la misma palabra del código. 
      Si nuestro código espera corregir errores, entonces <m>D</m> debe ser sobreyectiva.
      </p>

<!-- Parece haber un error acá.  En primer lugar el código usualmente se define como la imagen de la función codificadora.  En segundo lugar no es para nada claro que exista una función con el dominio dado y finalmente no se entiende la condición de sobreyectividad ni su relación con la corrección de errores. -->


    <example xml:id="algcodes-example-block-code" permid="OVh">
      <p permid="CHc">El código de paridad desarrollado para detectar errores individuales en caracteres <acro>ASCII</acro> es un código de bloque <m>(8,7)</m>. La función codificadora es
        <me permid="Xyi">E(x_7, x_6, \ldots, x_1) = (x_8, x_7,  \ldots, x_1)
        </me>,
      donde <m>x_8 = x_7 + x_6 + \cdots + x_1</m> con la suma en <m>{\mathbb Z}_2</m>. </p>
    </example>

    <p permid="EaQ">Sean <m>{\mathbf x} = (x_1, \ldots, x_n)</m> y <m>{\mathbf y} = (y_1, \ldots, y_n)</m> <m>n</m>-tuplas binarias. La <term>distancia de Hamming</term><idx><h>Distancia de Hamming</h></idx> o <term>distancia</term>, <m>d({\mathbf x}, {\mathbf y})</m>, entre <m>{\mathbf x}</m> e <m>{\mathbf y}</m> es el número de bits en que <m>{\mathbf x}</m> e <m>{\mathbf y}</m> difieren. La distancia entre dos palabras del código es el mínimo número de errores de transmisión necesarios para transformar una de las palabras en la otra. La <term>distancia mínima</term><idx><h>Código</h><h>distancia mínima del</h></idx> para un código, <m>d_{\min}</m>, es el mínimo de todas las distancias <m>d({\mathbf x}, {\mathbf y})</m>, donde <m>{\mathbf x}</m> e <m>{\mathbf y}</m> son palabras distintas del código. El <idx><h>Peso de una palabra del código</h></idx><term>peso</term>, <m>w({\mathbf x})</m>, de una palabra de un código binario <m>{\mathbf x}</m> es el número de <m>1</m>s en <m>{\mathbf x}</m>. Claramente, <m>w({\mathbf x}) = d({\mathbf x}, {\mathbf 0})</m>, donde <m>{\mathbf 0} = (00 \cdots 0)</m>. <notation><usage><m>d(\mathbf x, \mathbf y)</m></usage><description>distancia de Hamming entre <m>\mathbf x</m> e <m>\mathbf y</m></description></notation> <notation><usage><m>d_{\min}</m></usage><description>la distancia mínima de un código</description></notation> <notation><usage><m>w(\mathbf x)</m></usage><description>el peso de <m>\mathbf x</m></description></notation></p>
 
    <example xml:id="algcodes-example-min-distance" permid="vcq">
      <p permid="iOl">Sean <m>{\mathbf x} = (10101)</m>, <m>{\mathbf y} = (11010)</m>, y <m>{\mathbf z} = (00011)</m> todas las palabras en un código <m>C</m>. Entonces tenemos las siguientes distancias de Hamming: 
        <me permid="DFr">d({\mathbf x},{\mathbf y}) = 4, \qquad d({\mathbf x},{\mathbf z}) = 3, \qquad d({\mathbf y},{\mathbf z}) = 3</me>.
      La distancia mínima para este código es 3 y los pesos son: 
      <me permid="jMA">w({\mathbf x}) = 3, \qquad w({\mathbf y}) = 3, \qquad w({\mathbf z}) = 2</me>.
    </p>
    </example>
 
    <p permid="khZ">La siguiente proposición lista algunas propiedades básicas sobre el peso de una palabra del código y la distancia entre dos palabras del código. La demostración se deja como ejercicio.
      </p>

    <proposition permid="iNY">
      <statement>
        <p permid="UKG">Sean <m>{\mathbf x}</m>, <m>{\mathbf y}</m>, y <m>{\mathbf z}</m>  <m>n</m>-tuplas binarias. Entonces 
          <ol permid="UDp">

            <li permid="CzL"><p permid="URK"><m>w({\mathbf x}) = d( {\mathbf x}, {\mathbf 0})</m>;</p></li>
 
            <li permid="iGU"><p permid="AYT"><m>d( {\mathbf x}, {\mathbf y}) \geq 0</m>;</p></li>
 
            <li permid="OOd"><p permid="hgc"><m>d( {\mathbf x}, {\mathbf y}) = 0</m> si y solo si <m>{\mathbf x} = {\mathbf y}</m>;</p></li>
 
            <li permid="uVm"><p permid="Nnl"><m>d( {\mathbf x}, {\mathbf y})= d( {\mathbf y}, {\mathbf x})</m>;</p></li>
 
            <li permid="bcv"><p permid="tuu"><m>d( {\mathbf x}, {\mathbf y}) \leq d( {\mathbf x}, {\mathbf z}) + d( {\mathbf z}, {\mathbf y})</m>.
      </p></li>
 
          </ol></p>
      </statement>
    </proposition>
 
    <p permid="Qpi">Los pesos en un código particular son usualmente mucho más fáciles de calcular que las distancias de Hamming entre todas las palabras del código. Si un código se construye cuidadosamente, podemos sacar provecho de este hecho.
      </p>
 
    <p permid="wwr">Supongamos que <m>{\mathbf x} = (1101)</m> e <m>{\mathbf y} = (1100)</m> son palabras en algún código. Si transmitimos <m>(1101)</m> y un error ocurre en el bit de más a la derecha, entonces se recibirá <m>(1100)</m>. Como <m>(1100)</m> es una palabra del código, el decodificador  decodificará <m>(1100)</m> como el mensaje transmitido. Este código claramente no es muy apropiado para la detección de errores. El problema es que <m>d({\mathbf x}, {\mathbf y}) = 1</m>. Si <m>{\mathbf x} = (1100)</m> e <m>{\mathbf y} = (1010)</m> son palabras del código, entonces <m>d({\mathbf x}, {\mathbf y}) = 2</m>. Si <m>{\mathbf x}</m> se transmite y ocurre un solo error, entonces <m>{\mathbf y}</m> nunca puede ser recibido. La <xref ref="algcodes-table-4-bit-words"/> entrega las distancias entre todas las palabras del código de 4-bits en que los primeros tres bits son de información y el cuarto es un bit de control de paridad. Podemos ver que la distancia mínima acá es <m>2</m>; luego, el código es apto como código de detección de un error. </p>
 
    <table xml:id="algcodes-table-4-bit-words" permid="hgp">
      <title>Distancias entre palabras de código de 4-bit</title>
       <tabular halign="center" top="medium" left="medium" right="medium" permid="Nny">
          <row bottom="medium">
            <cell/>
            <cell><m>0000</m></cell>
            <cell><m>0011</m></cell>
            <cell><m>0101</m></cell>
            <cell><m>0110</m></cell>
            <cell><m>1001</m></cell>
            <cell><m>1010</m></cell>
            <cell><m>1100</m></cell>
            <cell><m>1111</m></cell>
          </row>
          <row>
            <cell><m>0000</m></cell>
            <cell><m>0</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>4</m></cell>
          </row>
          <row>
            <cell><m>0011</m></cell>
            <cell><m>2</m></cell>
            <cell><m>0</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>4 </m></cell>
            <cell><m>2</m></cell>
          </row>
          <row>
            <cell><m>0101</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>0</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>4</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
          </row>
          <row>
            <cell><m>0110</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>0</m></cell>
            <cell><m>4</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
          </row>
          <row>
            <cell><m>1001</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>4</m></cell>
            <cell><m>0</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
          </row>
          <row>
            <cell><m>1010</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>4</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>0</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
          </row>
          <row>
            <cell><m>1100</m></cell>
            <cell><m>2</m></cell>
            <cell><m>4</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>0</m></cell>
            <cell><m>2</m></cell>
          </row>
          <row bottom="medium">
            <cell><m>1111</m></cell>
            <cell><m>4</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>2</m></cell>
            <cell><m>0</m></cell>
          </row>
        </tabular>
    </table>

    <p permid="cDA">Para determinar exactamente cuáles son las capacidades de detección y corrección de errores de un código, debemos analizar la distancia mínima para el código. Sean <m>{\mathbf x}</m> e <m>{\mathbf y}</m> palabras del código. Si <m>d({\mathbf x}, {\mathbf y}) = 1</m> y ocurre un error donde difieren <m>{\mathbf x}</m> e <m>{\mathbf y}</m>, entonces <m>{\mathbf x}</m> se transforma en <m>{\mathbf y}</m>. La palabra recibida es <m>{\mathbf y}</m> y no se produce ningún mensaje de error. Ahora supongamos que <m>d({\mathbf x}, {\mathbf y}) = 2</m>. Entonces un único error no puede transformar <m>{\mathbf x}</m> en <m>{\mathbf y}</m>. Por lo tanto, si <m>d_{\min} = 2</m>, tenemos la habilidad de detectar errores únicos. Pero, supongamos que <m>d({\mathbf x}, {\mathbf y}) = 2</m>, <m>{\mathbf y}</m> es enviado, y se recibe una palabra <m>{\mathbf z}</m> que no está en el código tal que <me permid="PTJ">d({\mathbf x}, {\mathbf z}) = d({\mathbf y}, {\mathbf z}) = 1</me>. Entonces el decodificador no puede decidir entre <m>{\mathbf x}</m> e <m>{\mathbf y}</m>. Si bien estamos concientes de que se cometió un error, no sabemos cuál fue ese error.
      </p>
 
    <p permid="IKJ">Supongamos que <m>d_{\min} \geq 3</m>. Entonces el algoritmo de decodificación de máxima probabilidad corrige todos los errores únicos. Comenzando con una palabra <m>{\mathbf x}</m> del código, un error de un único bit en la transmisión da <m>{\mathbf y}</m> con <m>d({\mathbf x}, {\mathbf y}) = 1</m>, pero <m>d({\mathbf z}, {\mathbf y}) \geq 2</m> para cualquier otra palabra <m>{\mathbf z} \neq {\mathbf x}</m> del código. Si no necesitamos corregir errores, entonces podemos detectar más de un error cuando un código tiene distancia mínima mayor o igual a <m>3</m>.
      </p>  
 
    <theorem xml:id="algcodes-theorem-min-distance" permid="CGP">
      <statement>
        <p permid="ryd">Sea <m>C</m> un código con <m>d_{\min} = 2n + 1</m>. Entonces <m>C</m> puede corregir cualquiera <m>n</m> o menos errores.  Alternativamente, <m>2n</m> o menos errores cualquiera pueden ser detectados con <m>C</m>.
      </p>
      </statement>
      <proof permid="cDn">
        <p permid="JBH">Supongamos que se envía una palabra <m>{\mathbf x}</m> del código y que se recibe la palabra <m>{\mathbf y}</m> con a lo más <m>n</m> errores. Entonces <m>d( {\mathbf x}, {\mathbf y}) \leq n</m>. Si <m>{\mathbf z}</m> es cualquier palabra del código distinta de <m>{\mathbf x}</m>, entonces
          <me permid="waS">2n+1 \leq d( {\mathbf x}, {\mathbf z}) \leq d( {\mathbf x}, {\mathbf y}) + d( {\mathbf y}, {\mathbf z}) \leq n + d( {\mathbf y}, {\mathbf z})</me>.
        Luego, <m>d({\mathbf y}, {\mathbf z} ) \geq n+1</m> e <m>{\mathbf y}</m> será decodificada correctamente como <m>{\mathbf x}</m>. Ahora supongamos que se transmite <m>{\mathbf x}</m> recibiéndose <m>{\mathbf y}</m> y que al menos uno pero no más de <m>2n</m> errores han ocurrido. Entonces <m>1 \leq d( {\mathbf x}, {\mathbf y} ) \leq 2n</m>.  Como la distancia mínima entre palabras del código es <m>2n +1</m>, <m>{\mathbf y}</m> no puede ser una palabra del código.  Así, el código puede detectar entre  <m>1</m> y  <m>2n</m> errores.
      </p>
      </proof>
    </theorem>

    <example xml:id="algcodes-example-single-correct" permid="bjz">
        <p permid="OVu">
          En <xref ref="algcodes-table-hamming-distance"/>,
          las palabras del código <m>{\mathbf c}_1 = (00000)</m>,
          <m>{\mathbf c}_2 = (00111)</m>,
          <m>{\mathbf c}_3 = (11100)</m>,
          y <m>{\mathbf c}_4 = (11011)</m> determinan un único código de corrección de un error.
        </p>

        <table xml:id="algcodes-table-hamming-distance" permid="oKO">
          <title>Distancias de Hamming para un código de corrección de errores</title>
          <tabular halign="center" top="medium" left="medium" right="medium" permid="URX">
            <row bottom="medium">
              <cell/>
              <cell><m>00000</m></cell>
              <cell><m>00111</m></cell>
              <cell><m>11100</m></cell>
              <cell><m>11011</m></cell>
            </row>
            <row>
              <cell><m>00000 </m></cell>
              <cell><m>0</m></cell>
              <cell><m>3</m></cell>
              <cell><m>3</m></cell>
              <cell><m>4</m></cell>
            </row>
            <row>
              <cell><m>00111 </m></cell>
              <cell><m>3</m></cell>
              <cell><m>0</m></cell>
              <cell><m>4</m></cell>
              <cell><m>3</m></cell>
            </row>
            <row>
              <cell><m>11100 </m></cell>
              <cell><m>3</m></cell>
              <cell><m>4</m></cell>
              <cell><m>0</m></cell>
              <cell><m>3</m></cell>
            </row>
            <row bottom="medium">
              <cell><m>11011 </m></cell>
              <cell><m>4</m></cell>
              <cell><m>3</m></cell>
              <cell><m>3</m></cell>
              <cell><m>0</m></cell>
            </row>
          </tabular>

        </table>
      </example>
 
    </subsection> 

    <subsection xml:id="algcodes-subsection-historical-note" permid="coS">
      <title>Nota Histórica</title> 

      <p permid="oRS">La teoría moderna de códigos comenzó en 1948 con la publicación de C. Shannon<idx><h>Shannon, C.</h></idx>, titulada <q>A Mathematical Theory of Information</q> [7]. En su artículo, Shannon ofreció un ejemplo de un código algebraico, y el Teorema de Shannon estableció precisamente qué tan bueno puede llegar a ser un código. Richard Hamming<idx><h>Hamming, R.</h></idx> comenzó a trabajar con códigos lineales en Bell Labs a finales de los 1940s y principios de los 1950s después de sufrir la frustración de que los programas que corría no eran capaces de recuperarse de simples errores generados por ruido. La teoría de códigos ha crecido tremendamente en las décadas siguientes a estos trabajos. <em>The Theory of Error-Correcting Codes</em>, de MacWilliams y Sloane [5], publicado en 1977, ya contenía más de 1500 citas. Códigos lineales (códigos de bloque <m>(32, 6)</m> de Reed-Muller) fueron usados en las sondas espaciales Mariner de la NASA.  Sondas espaciales posteriores como los Voyager han usado los llamados códigos de convolución.  Actualmente, hay investigación activa respecto a códigos Goppa, que dependen fuertemente de geometría algebraica.
      </p>

     </subsection>
     
  </section>

  <section xml:id="algcodes-section-linear-codes" permid="RPN">
    <title>Códigos Lineales</title>

    <introduction permid="EaD">
 
      <p permid="hIS">Para ganar más información sobre un código particular y desarrollar técnicas más eficientes de codificación, decodificación y detección de errores, necesitaremos agregar mayor estructura a nuestros códigos. Una forma de lograr esto es pedir que el código además sea un grupo. Un <term>código de grupo</term><idx><h>Grupo</h><h>código de</h></idx> es un código que además es un subgrupo de <m>{\mathbb Z}_2^n</m>.
      </p> 
   
      <p permid="NQb">Para verificar que un código es un código de grupo, solo necesitamos verificar una cosa. Si sumamos dos elementos en el código, el resultado debe ser una <m>n</m>-tupla que nuevamente esté en el código. No es necesario verificar que el elemento inverso de la <m>n</m>-tupla esté en el código, pues cada palabra del código es su propio inverso, tampoco es necesario verificar que <m>{\mathbf 0}</m> sea una palabra del código. Por ejemplo, <me permid="cib">(11000101) + (11000101) = (00000000)</me>.
    </p>
   

      <example xml:id="algcodes-example-weights" permid="aOa">
        <p permid="vcD">Supongamos que tenemos un código que consiste de las siguientes 7-tuplas: 
          <md permid="Ipk">
            <mrow> &amp;(0000000) &amp; &amp; (0001111) &amp;  &amp; (0010101) &amp; &amp; (0011010)</mrow>
            <mrow> &amp;(0100110) &amp; &amp; (0101001) &amp; &amp; (0110011) &amp; &amp; (0111100)</mrow>
            <mrow> &amp;(1000011) &amp; &amp; (1001100) &amp; &amp; (1010110) &amp; &amp; (1011001)</mrow>
            <mrow> &amp;(1100101) &amp; &amp; (1101010) &amp; &amp; (1110000) &amp; &amp; (1111111)</mrow>
          </md>.
        Es una tarea sencilla, aunque tediosa la de verificar que este código es un subgrupo de <m>{\mathbb Z}_2^7</m> y que por lo tanto, es un código de grupo. Este código detecta un error y corrige un error, pero calcular todas las distancias entre pares de palabras del código para determinar que <m>d_{\min} = 3</m> es un proceso largo y tedioso. Es mucho más sencillo ver que el peso mínimo de todas las palabras no nulas es <m>3</m>. Como veremos pronto, esto no es una coincidencia. Pero la relación entre pesos y distancias en un código particular es fuertemente dependiente del hecho que el código sea un grupo.
      </p>
      </example>
   
      <lemma permid="Weh">
        <statement>
          <p permid="tnq">Sean <m>{\mathbf x}</m> e <m>{\mathbf y}</m> <m>n</m>-tuplas binarias. Entonces <m>w({\mathbf x} + {\mathbf y}) = d({\mathbf x}, {\mathbf y})</m>.
      </p>
        </statement>
        <proof permid="FPQ">
          <p permid="pIQ">Supongamos que <m>{\mathbf x}</m> e <m>{\mathbf y}</m> son <m>n</m>-tuplas binarias. Entonces la distancia entre <m>{\mathbf x}</m> e <m>{\mathbf y}</m> es exactamente el número de lugares en los que difieren <m>{\mathbf x}</m> e <m>{\mathbf y}</m>. Pero <m>{\mathbf x}</m> e <m>{\mathbf y}</m> difieren en una coordenada particular si y solo si la suma es <m>1</m> en esa coordenada, pues
            <md permid="owt">
              <mrow>1 + 1 &amp; = 0</mrow>
              <mrow>0 + 0 &amp; = 0</mrow>
              <mrow>1 + 0 &amp; = 1</mrow>
              <mrow>0 + 1 &amp; = 1</mrow>
            </md>.
          Así, el peso de la suma es igual a la distancia entre las dos palabras.
      </p>
        </proof>
      </lemma>
   
      <theorem permid="sRE">
        <statement>
          <p permid="XFm">Sea <m>d_{\min}</m> la distancia mínima para un código de grupo <m>C</m>. Entonces <m>d_{\min}</m> es el mínimo de todos los pesos de las palabras no nulas en <m>C</m>. Es decir, 
            <me permid="UDC">d_{\min} = \min\{ w({\mathbf x}) : { {\mathbf x} \neq {\mathbf 0} } \}</me>.
    </p>
        </statement>
        <proof permid="IKw">
        <p permid="VPZ">Observe que
          <md permid="AKL">
            <mrow>d_{\min} &amp; =  \min \{ d({\mathbf x},{\mathbf y}) : {\mathbf x}\neq{\mathbf y} \}</mrow>
            <mrow>&amp;=  \min \{ d({\mathbf x},{\mathbf y}) : {\mathbf x}+{\mathbf y} \neq {\mathbf 0} \}</mrow>
            <mrow>&amp;= \min\{ w({\mathbf x} + {\mathbf y}) : {\mathbf x}+{\mathbf y}\neq {\mathbf 0} \}</mrow>
            <mrow>&amp; =  \min\{ w({\mathbf z}) : {\mathbf z} \neq {\mathbf 0} \}</mrow>
          </md>.
          </p>
        </proof>
      </theorem>
    </introduction>

    <subsection xml:id="algcodes-subsection-linear-codes" permid="Iwb">
      <title>Códigos Lineales</title>
 
       <p permid="UZb">Del <xref ref="algcodes-example-weights"/>, es ahora fácil verificar que el mínimo peso distinto de cero es <m>3</m>; luego, el código realmente detecta y corrige todos los errores individuales. Hemos reducido el problema de encontrar <q>buenos</q> códigos al de generar códigos de grupo. Una forma fácil de generar códigos de grupo, es emplear un poco de teoría de matrices.
      </p>
 
      <p permid="Bgk">Se define el <term>producto interno</term><idx><h>Producto interno</h></idx> de dos <m>n</m>-tuplas binarias como 
        <me permid="gRU">{\mathbf x} \cdot {\mathbf y} = x_1 y_1 + \cdots + x_n y_n
        </me>,
      donde <m>{\mathbf x} = (x_1, x_2, \ldots, x_n)^\transpose</m> e <m>{\mathbf y} = (y_1, y_2, \ldots, y_n)^\transpose</m> son vectores columna.
      <fn> Como estaremos trabajando con matrices, escribiremos las <m>n</m>-tuplas binarias como vectores columna por el resto del capítulo.
      </fn> Por ejemplo, si <m>{\mathbf x} = (011001)^\transpose</m> e <m>{\mathbf y} = (110101)^\transpose</m>, entonces <m>{\mathbf x} \cdot {\mathbf y} = 0</m>. También podemos pensar el producto interno como el producto de un vector fila con un vector columna; es decir, 
        <md permid="MZd">
          <mrow>{\mathbf x} \cdot {\mathbf y} &amp; = {\mathbf x}^\transpose  {\mathbf y}</mrow>
          <mrow>&amp; =
          \begin{pmatrix}
          x_1 &amp; x_2 &amp; \cdots &amp; x_n
          \end{pmatrix}
          \begin{pmatrix}
          y_1 \\ y_2 \\ \vdots \\ y_n
          \end{pmatrix}</mrow>
          <mrow>&amp; = x_{1}y_{1} + x_{2}y_{2} + \cdots + x_{n}y_{n}</mrow>
        </md>.
        </p>
 
      <example xml:id="algcodes-example-matrixcodes" permid="nxR">
        <p permid="bjM">Supongamos que las palabras a ser codificadas consisten de todas las <m>3</m>-tuples binarias y que nuestro mecanismo de codificación es el de control de paridad. Para codificar una <m>3</m>-tupla arbitraria, agregamos un cuarto bit para obtener un número par de <m>1</m>s. Note que una <m>n</m>-tupla arbitraria <m>{\mathbf x} = (x_1, x_2, \ldots, x_n)^\transpose</m> tiene un número par de <m>1</m>s exactamente cuando <m>x_1 + x_2 + \cdots + x_n = 0</m>; luego, una <m>4</m>-tupla <m>{\mathbf x} = (x_1, x_2, x_3, x_4)^\transpose</m> tiene un número par de <m>1</m>s si y solo si <m> x_1+ x_2+ x_3+ x_4 = 0</m>, o 
          <me permid="tgm">
            {\mathbf x} \cdot {\mathbf 1} =  {\mathbf x}^\transpose {\mathbf 1} =
            \begin{pmatrix}
            x_1 &amp; x_2 &amp; x_3 &amp; x_4
            \end{pmatrix}
            \begin{pmatrix}
            1 \\ 1 \\ 1 \\ 1
            \end{pmatrix} = 0
          </me>.
        Este ejemplo nos da esperanza de que haya una conexión entre las matrices y la teoría de códigos.
      </p>
      </example>
 
      <p permid="hnt">Sea <m>{\mathbb M}_{m \times n}({\mathbb Z}_2)</m> el conjunto de todas las matrices de <m>m \times n</m> con coeficientes en  <m>{\mathbb Z}_2</m>. Hacemos operaciones entre las matrices como siempre excepto que todas nuestras operaciones de suma y producto ocurren en  <m>{\mathbb Z}_2</m>. Defina el <term>espacio nulo</term><idx><h>Matriz</h><h>espacio nulo de una</h></idx><idx><h>Espacio nulo</h><h>de una matriz</h></idx> de una matriz <m>H \in {\mathbb M}_{m \times n}({\mathbb Z}_2)</m> como el conjunto de todas las <m>n</m>-tuplas binarias <m>{\mathbf x}</m> tales que <m>H{\mathbf x} = {\mathbf 0}</m>. Denotamos el espacio nulo de una matriz <m>H</m> por <m>\Null(H)</m>. <notation><usage><m>\mathbb M_{m \times n}(\mathbf Z_2)</m></usage><description>el conjunto de matrices de <m>m \times n</m> con coeficientes en <m>\mathbb Z_2</m></description></notation> <notation><usage><m>\Null(H)</m></usage><description>espacio nulo de una matriz <m>H</m></description></notation></p> 

      <example xml:id="algcodes-example-group-code" permid="TFa">
        <p permid="HqV">Supongamos que
          <me permid="Znv">
            H =
            \begin{pmatrix}
            0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 1 &amp; 1
            \end{pmatrix}
          </me>.
        Para que una <m>5</m>-tupla <m>{\mathbf x} = (x_1, x_2, x_3, x_4, x_5)^\transpose</m> esté en el espacio nulo de <m>H</m>, <m>H{\mathbf x} = {\mathbf 0}</m>. Equivalentemente, se debe satisfacer el siguiente sistema de ecuaciones:   
          <md permid="lBN">
          <mrow>x_2 +  x_4  &amp; =  0</mrow>
          <mrow>x_1 +  x_2 + x_3  + x_4   &amp; =  0</mrow>
          <mrow>x_3  + x_4  +  x_5 &amp; =  0</mrow>
          </md>.
        El conjunto de las <m>5</m>-tuplas binarias que satisfacen estas ecuaciones es
        <me permid="FuE">(00000) \qquad (11110) \qquad (10101) \qquad (01011)</me>.
        Es fácil determinar que este código es un código de grupo.
      </p>
      </example>
   
      <theorem permid="HqI">
        <statement>
          <p permid="DMv">Sea <m>H</m> en <m>{\mathbb M}_{m \times n}({\mathbb Z}_2)</m>. Entonces el espacio nulo de <m>H</m> es un código de grupo.
      </p>
        </statement>
        <proof permid="oRF">
          <p permid="BXi">Como cada elemento de <m>{\mathbb Z}_2^n</m> es su propio inverso, lo único que necesita ser verificado es la clausura. Sean <m>{\mathbf x}, {\mathbf y} \in \Null(H)</m> para alguna matriz <m>H</m> en <m>{\mathbb M}_{m \times n}({\mathbb Z}_2)</m>. Entonces <m>H{\mathbf x} = {\mathbf 0}</m> y <m>H{\mathbf y} = {\mathbf 0}</m>. Así
            <me permid="RIW">H({\mathbf x}+{\mathbf y}) = H{\mathbf x} + H{\mathbf y} = {\mathbf 0} + {\mathbf 0} = {\mathbf 0}</me>.
          Luego, <m>{\mathbf x} + {\mathbf y}</m> está en el espacio nulo de  <m>H</m> y por lo tanto es una palabra del código.
      </p>
        </proof>
      </theorem>

<!-- typo correction.  Suggested by J. Buller. -->
<!-- TWJ - 12/20/2011 -->

      <p permid="NuC">Un código es un <term>código lineal</term><idx><h>Código</h><h>lineal</h></idx> si está determinado por el espacio nulo de alguna matriz <m>H \in {\mathbb M}_{m \times n}({\mathbb Z}_2)</m>.
      </p> 
 
      <example xml:id="algcodes-example-linear-code" permid="zMj">
        <p permid="nye">Sea <m>C</m> el código dado por la matriz
          <me permid="xQf">
            H =
            \begin{pmatrix}
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
            1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
          </me>.
        Supongamos que se recibe la <m>6</m>-tupla <m>{\mathbf x} = (010011)^\transpose</m>. Es simplemente cuestión de multiplicar matrices para determinar si <m>{\mathbf x}</m> está o no en el código. Como 
          <me permid="dXo">
            H{\mathbf x} =
            \begin{pmatrix} 
            0 \\ 1 \\ 1
            \end{pmatrix}
          </me>,
        la palabra recibida no está en el código.  Debemos intentar corregirla o pedir que sea transmitida nuevamente.
      </p>
      </example>

<!-- typo correction.  Suggested by J. Buller. -->
<!-- TWJ - 12/20/2011 -->

    </subsection>
 
  </section>

  <section xml:id="algcodes-section-parity-check" permid="xWW">
    <title>Matrices Verificadora y Generadora</title>
 
    <p permid="Mpj">Debemos encontrar una forma sistemática de generar códigos lineales así como métodos rápidos de decodificación. Examinando las propiedades de la matriz <m>H</m> y eligiendo <m>H</m> cuidadosamente, es posible desarrollar métodos muy eficientes para codificar y decodificar mensajes. Con este objetivo, introduciremos la matriz generadora estándar y la matriz verificadora canónica.
      </p>

    <p permid="sws">Supongamos que <m>H</m> es una matriz de <m>m \times n</m> con coeficiente en <m>{\mathbb Z}_2</m> y <m>n \gt m</m>. las últimas <m>m</m> columnas de la matriz forman la matriz identidad de <m>m \times m</m>, <m>I_m</m>, entonces la matriz es una <idx><h>Matriz</h><h>verficadora</h></idx><term>matriz verificadora canónica</term>. Más específicamente, <m>H= (A \mid I_m)</m>, donde <m>A</m> es la matriz de <m>m \times (n-m)</m> 
      <me permid="Kex">
        \begin{pmatrix}
        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1,n-m} \\
        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2,n-m} \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots    \\
        a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{m,n-m}
        \end{pmatrix}
      </me>
    y <m>I_m</m> es la matriz identidad de <m>m \times m</m>
      <me permid="qlG">
        \begin{pmatrix}
        1 &amp; 0 &amp; \cdots &amp; 0 \\
        0 &amp; 1 &amp; \cdots &amp; 0 \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        0 &amp; 0 &amp; \cdots &amp; 1
        \end{pmatrix}
      </me>.
    Con cada matriz verificadora canónica podemos asociar una <term>matriz generadora estándar</term> de <m>n \times (n-m)</m> <idx><h>Matriz</h><h>generadora</h></idx> 
      <me permid="WsP">G = \left( \frac{I_{n-m}}{A} \right)</me>.
    Nuestro objetivo será mostrar que existe un <m>\mathbf x</m> que satisfaga <m>G {\mathbf x} = {\mathbf y}</m> si y solo si <m>H{\mathbf y} = {\mathbf 0}</m>.  dado un bloque <m>{\mathbf x}</m> a ser codificado, la matriz <m>G</m> nos permitirá codificarlo rápidamente a una palabra <m>{\mathbf y}</m> del código lineal.
      </p>

    <example xml:id="algcodes-example-parity-check" permid="GVj">
      <p permid="TFn">Supongamos que tenemos las siguientes ocho palabras por codificar:
        <me permid="CzY">(000), (001), (010), \ldots, (111)</me>.
      Para
        <me permid="iHh">
          A =
          \begin{pmatrix}
          0 &amp; 1 &amp; 1 \\
          1 &amp; 1 &amp; 0 \\
          1 &amp; 0 &amp; 1
          \end{pmatrix}
        </me>,
      la matrices generadora estándar y verificadora canónica son 
         <me permid="OOq">
          G=
          \begin{pmatrix}
          1 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 0 \\
          0 &amp; 0 &amp; 1 \\
          0 &amp; 1 &amp; 1 \\
          1 &amp; 1 &amp; 0 \\
          1 &amp; 0 &amp; 1
          \end{pmatrix}
        </me>
      y
        <me permid="uVz">
          H =
          \begin{pmatrix}
          0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
          \end{pmatrix}
        </me>,
      respectivamente.
      </p>
 
      <p permid="zMw">Observe que las filas en <m>H</m>  representan las verificaciones de paridad en ciertas posiciones de las <m>6</m>-tuplas. Los <m>1</m>s en la matriz identidad sirven como verificadores de paridad para los <m>1</m>s en la misma fila. Si <m>{\mathbf x} = (x_1, x_2, x_3, x_4, x_5, x_6)</m>, entonces 
        <me permid="bcI">{\mathbf 0}
        =
        H{\mathbf x}
        =
        \begin{pmatrix}
        x_2 + x_3 + x_4 \\
        x_1 + x_2 + x_5\\
        x_1 + x_3 + x_6
        \end{pmatrix}
        </me>,
      lo que produce un sistema de ecuaciones:
        <md permid="nra">
          <mrow>x_2 + x_3 + x_4 &amp; = 0</mrow>
          <mrow>x_1 + x_2 + x_5 &amp; = 0</mrow>
          <mrow>x_1 + x_3 + x_6 &amp; = 0</mrow>
        </md>.
      Acá <m>x_4</m> sirve como bit de control para <m>x_2</m> y <m>x_3</m>; <m>x_5</m> es un bit de control para <m>x_1</m> y <m>x_2</m>; y <m>x_6</m> es un bit de control para <m>x_1</m> y <m>x_3</m>. La matriz identidad impide que <m>x_4</m>, <m>x_5</m>, y <m>x_6</m> tengan que controlarse entre ellos. Luego, <m>x_1</m>, <m>x_2</m>, y <m>x_3</m> pueden ser arbitrarios pero <m>x_4</m>, <m>x_5</m>, y <m>x_6</m> deben ser escogidos de manera de asegurar las paridades respectivas. Se calcula fácilmente que el espacio nulo de <m>H</m> es
        <me permid="HjR">\begin{array}{cccc}
        (000000) &amp; (001101) &amp; (010110) &amp; (011011) \\
        (100011) &amp; (101110) &amp; (110101) &amp; (111000).
        \end{array}</me>
      Una forma aún más fácil de calcular el espacio nulo es con la matriz generadora <m>G</m> (<xref ref="algcodes-table-matrix-gen-code"/>). </p>
    </example>
    
    <table xml:id="algcodes-table-matrix-gen-code" permid="RXr">
      <title>A matrix-generated code</title>
      <tabular halign="center" top="medium" permid="yeA">
        <row bottom="medium">
          <cell>Palabra de mensaje <m>\mathbf x</m></cell>
          <cell>palabra codificada <m>G \mathbf x</m></cell>
        </row>
        <row>
          <cell><m>000</m></cell>
          <cell><m>000000</m></cell>
        </row>
        <row>
          <cell><m>001</m></cell>
          <cell><m>001101</m></cell>
        </row>
        <row>
          <cell><m>010</m></cell>
          <cell><m>010110</m></cell>
        </row>
        <row>
          <cell><m>011</m></cell>
          <cell><m>011011</m></cell>
        </row>
        <row>
          <cell><m>100</m></cell>
          <cell><m>100011</m></cell>
        </row>
        <row>
          <cell><m>101</m></cell>
          <cell><m>101110</m></cell>
        </row>
        <row>
          <cell><m>110</m></cell>
          <cell><m>110101</m></cell>
        </row>
        <row bottom="medium">
          <cell><m>111</m></cell>
          <cell><m>111000</m></cell>
        </row>
      </tabular>

    </table>    

    <theorem permid="YYN">
      <statement>
        <p permid="jTE">Si <m>H \in {\mathbb M}_{m \times n}({\mathbb Z}_2)</m> es una matriz verificadora canónica, entonces <m>\Null(H)</m> consiste de todas las <m>{\mathbf x} \in {\mathbb Z}_2^n</m> cuyos primeros <m>n-m</m> bits son arbitrarios pero cuyos últimos <m>m</m> bits están determinados por <m>H{\mathbf x} = {\mathbf 0}</m>. Cada uno de los últimos <m>m</m> bits sirve como control de paridad para algunos de los primeros <m>n-m</m> bits. Luego, <m>H</m> da lugar a un código de bloque <m>(n, n-m)</m>.
      </p>
      </statement>
    </theorem>
 
    <p permid="YDB">Dejamos la demostración de este teorema como ejercicio. A la luz del teorema, los primeros <m>n - m</m> bits de <m>{\mathbf x}</m> se denominan <term>bits de información</term> y los últimos <m>m</m> bits se denominan <term>bits de verificación</term>. En el <xref ref="algcodes-example-parity-check"/>,  los primeros tres bits son de información y los últimos tres son bits de verificación.
      </p>
 
    <theorem permid="FfW">
      <statement>
        <p permid="QaN">Supongamos que <m>G</m> es una matriz generadora estándar de <m>n \times k</m>.  Entonces <m>C = \left\{{\mathbf y} : G{\mathbf x} ={\mathbf y}\text{ para }{\mathbf x}\in {\mathbb  Z}_2^k\right\}</m> es un código de bloque <m>(n,k)</m>. Más específicamente, <m>C</m> es un código de grupo.
      </p>
      </statement>
      <proof permid="UYO">
        <p permid="ier">Sean <m>G {\mathbf x}_1 = {\mathbf y}_1</m> y <m>G {\mathbf x}_2 ={\mathbf y}_2</m> dos palabras del código. Entonces <m>{\mathbf y}_1 + {\mathbf y}_2</m> está en <m>C</m> pues 
          <me permid="Tyj">G( {\mathbf x}_1 + {\mathbf x}_2) = G {\mathbf x}_1 + G {\mathbf x}_2 = {\mathbf y}_1 + {\mathbf y}_2</me>.
        Debemos mostrar además que dos bloques de mensaje diferentes no pueden ser codificados a la misma palabra del código. Es decir, debemos mostrar que si <m>G {\mathbf x} = G {\mathbf y}</m>, entonces <m>{\mathbf x} = {\mathbf y}</m>.  Supongamos que <m>G {\mathbf x} = G {\mathbf y}</m>. Entonces
          <me permid="zFs">G {\mathbf x} - G {\mathbf y} = G( {\mathbf x} - {\mathbf y}) = {\mathbf 0}</me>.
        Pero las primeras <m>k</m> coordenadas en <m>G( {\mathbf x} - {\mathbf y})</m> son exactamente <m>x_1 -y_1, \ldots, x_k - y_k</m>, pues están determinadas por la matriz identidad, <m>I_k</m>, que es parte de <m>G</m>. Luego, <m>G( {\mathbf x} - {\mathbf y}) = {\mathbf 0}</m> si y solo si <m>{\mathbf x} = {\mathbf y}</m>.
      </p>
      </proof>
    </theorem>
 
    <p permid="EKK">Antes de demostrar la relación entre la matriz verificadora canónica y la matriz generadora estándar, demostraremos un lema.
      </p>
 
    <lemma xml:id="algcodes-lemma-parity-check" permid="Clq">
      <statement>
        <p permid="Zuz">Sea <m>H = (A \mid I_m )</m> una matriz verificadora canónica de <m>m \times n</m> y <m>G = \left( \frac{I_{n-m} }{A} \right)</m> la correspondiente matriz generadora estándar de <m>n \times (n-m)</m>. Entonces <m>HG = {\mathbf 0}</m>.
      </p>
      </statement>
      <proof permid="lWZ">
        <p permid="OlA">Sea <m>C = HG</m>.  El coeficiente <m>ij</m>th de <m>C</m> es
          <md permid="LTK">
            <mrow>c_{ij} &amp; = \sum_{k=1}^n h_{ik} g_{kj}</mrow>
            <mrow>&amp; =  \sum_{k=1}^{n-m} h_{ik} g_{kj} + \sum_{k=n-m+1}^n h_{ik} g_{kj}</mrow>
            <mrow>&amp; = \sum_{k=1}^{n-m} a_{ik} \delta_{kj} + \sum_{k=n-m+1}^n \delta_{i-(m-n),k} a_{kj}</mrow>
            <mrow>&amp; =  a_{ij} + a_{ij}</mrow>
            <mrow>&amp; = 0</mrow>
          </md>,
        donde
          <me permid="fMB">\delta_{ij} =
          \begin{cases}
          1 &amp; i = j \\
          0 &amp; i \neq j
          \end{cases}</me>
        es la delta de Kronecker<idx><h>delta de Kronecker</h></idx>. <notation><usage><m>\delta_{ij}</m></usage><description>delta de Kronecker</description></notation></p>
      </proof>
    </lemma>

    <theorem permid="lnf">
      <statement>
        <p permid="whW">Sea <m>H = (A \mid I_m )</m> una matriz verificadora canónica de <m>m \times n</m> y sea <m>G = \left( \frac{I_{n-m} }{A} \right) </m> la matriz generadora estándar de <m>n \times (n-m)</m> asociada con <m>H</m>. Sea <m>C</m> el código generado por <m>G</m>. Entonces <m>{\mathbf y}</m> está en <m>C</m> si y solo si <m>H {\mathbf y} = {\mathbf 0}</m>. En particular, <m>C</m> es un código lineal con matriz verificadora canónica <m>H</m>.
      </p>
      </statement>
      <proof permid="BfX">
        <p permid="usJ">Primero supongamos que <m>{\mathbf y} \in C</m>. Entonces <m>G {\mathbf x} = {\mathbf y}</m> para algún <m>{\mathbf x} \in {\mathbb Z}_2^m</m>. Por el <xref ref="algcodes-lemma-parity-check"/>, <m>H {\mathbf y} = HG {\mathbf x} = {\mathbf 0}</m>.
      </p>
 
        <p permid="azS">Recíprocamente, supongamos que <m>{\mathbf y} = (y_1, \ldots, y_n)^\transpose</m> está en el espacio nulo de  <m>H</m>.  Debemos encontrar <m>{\mathbf x}</m> en <m>{\mathbb Z}_2^{n-m}</m> tal que <m>G {\mathbf x}^\transpose = {\mathbf y}</m>. Como <m>H {\mathbf y} = {\mathbf 0}</m>, se debe satisfacer el siguiente conjunto de ecuaciones:  
          <md permid="saT">
            <mrow>a_{11} y_1 + a_{12} y_2 + \cdots + a_{1, n-m} y_{n-m} + y_{n-m+1} &amp; = 0</mrow>
            <mrow>a_{21} y_1 + a_{22} y_2 + \cdots + a_{2, n-m} y_{n-m} + y_{n-m+2} &amp; = 0</mrow>
            <mrow>&amp; \vdots  </mrow>
            <mrow>a_{m1} y_1 + a_{m2} y_2 + \cdots + a_{m, n-m} y_{n-m} + y_{n-m+m} &amp; = 0</mrow>
          </md>.
        Equivalentemente, <m>y_{n-m+1}, \ldots, y_n</m> están determinados por <m>y_1, \ldots, y_{n-m}</m>: 
          <md permid="Yic">
            <mrow>y_{n-m+1} &amp; = a_{11} y_1 + a_{12} y_2 + \cdots + a_{1, n-m} y_{n-m}</mrow>
            <mrow>y_{n-m+2} &amp; = a_{21} y_1 + a_{22} y_2 + \cdots + a_{2, n-m} y_{n-m}</mrow>
            <mrow>&amp; \vdots</mrow>
            <mrow>y_{n} &amp; = a_{m1} y_1 + a_{m2} y_2 + \cdots + a_{m, n-m} y_{n-m}</mrow>
          </md>.
        Por ende podemos tomar <m>x_i = y_i</m> para <m>i= 1, \ldots, n - m</m>.
      </p>
      </proof>
    </theorem>
 
    <p permid="kRT">Sería bueno poder calcular la distancia mínima de un código lineal directamente a partir de su matriz <m>H</m> para poder determinar las capacidades de detección y corrección de errores del código. Supongamos que  
      <md permid="Epl">
        <mrow>{\mathbf e}_1 &amp; = (100 \cdots 00)^\transpose</mrow>
        <mrow>{\mathbf e}_2 &amp; = (010 \cdots 00)^\transpose</mrow>
        <mrow>&amp; \vdots</mrow>
        <mrow>{\mathbf e}_n &amp; = (000 \cdots 01)^\transpose</mrow>
      </md>
    son la <m>n</m>-tuplas en <m>{\mathbb Z}_2^n</m> de peso <m>1</m>. Para una matriz binaria <m>H</m> de <m>m \times n</m>, <m>H{\mathbf e}_i</m> es exactamente la columna <m>i</m>-ésima de la matriz <m>H</m>.
      </p> 

    <example xml:id="algcodes-example-ith-column" permid="ncs">
      <p permid="fTF">Observe que
        <me permid="kwu">
          \begin{pmatrix}
          1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
          1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
          \end{pmatrix}
          \begin{pmatrix}
          0 \\ 1 \\ 0 \\ 0 \\ 0
          \end{pmatrix}
          =
          \begin{pmatrix}
          1 \\ 0 \\ 1
          \end{pmatrix}
        </me>.
    </p>
    </example>
 
    <p permid="QZc">Enunciamos el resultado en la siguiente proposición y dejamos su demostración como ejercicio.
      </p> 
 
    <proposition xml:id="algcodes-proposition-column" permid="JPP">
      <statement>
        <p permid="ARP">Sea <m>{\mathbf e}_i</m> la <m>n</m>-tupla binaria con un <m>1</m> en la <m>i</m>-ésima coordenada y <m>0</m> en todas las demás y supongamos que <m>H \in {\mathbb M}_{m \times n}({\mathbb Z}_2)</m>. Entonces <m>H{\mathbf e}_i</m> es la <m>i</m>-ésima columna de la matriz <m>H</m>. </p>
      </statement>
    </proposition>
 
    <theorem xml:id="algcodes-theorem-single-error" permid="Ruo">
      <statement>
        <p permid="cpf">Sea <m>H</m> una matriz binaria de <m>m \times n</m>. Entonces el espacio nulo de <m>H</m> es un código que puede detectar un error si y solo si ninguna columna de <m>H</m> consiste solamente de ceros.
      </p>
      </statement>
      <proof permid="hng">
        <p permid="GHb">Supongamos que <m>\Null(H)</m> es un código que detecta un error. Entonces la distancia mínima del código debe ser al menos <m>2</m>. Como el espacio nulo es un código de grupo, es necesario que el código no tenga ninguna palabra de peso menor a <m>2</m> aparte de la palabra cero. Es decir, <m>{\mathbf e}_i</m> no debe ser una palabra del código para <m>i = 1, \ldots, n</m>. Dado que <m>H{\mathbf e}_i</m> es la <m>i</m>ésima columna de <m>H</m>, la única forma en que <m>{\mathbf e} _i</m> podría estar en el espacio nulo de <m>H</m> si la columna <m>i</m>ésima fuera todo ceros, lo cual es imposible; por lo tanto, el código debe tener la capacidad de detectar al menos errores individuales.
      </p>  

        <p permid="mOk">Recíprocamente, supongamos que ninguna columna de <m>H</m> es la columna cero. Por la <xref ref="algcodes-proposition-column"/>, <m>H{\mathbf e}_i \neq {\mathbf 0}</m>.
      </p>
      </proof>
    </theorem>

    <example xml:id="algcodes-example-null-space" permid="TjB">
      <p permid="MaO">Si consideramos las matrices
        <me permid="QDD">
          H_1 =
          \begin{pmatrix}
          1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
          1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
          \end{pmatrix}
        </me>
      y
        <me permid="wKM">
          H_2 =
          \begin{pmatrix}
          1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
          1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
          \end{pmatrix}
        </me>,
      entonces el espacio nulos de <m>H_1</m> es un código que detecta un error y el espacio nulo de <m>H_2</m> no lo es.
      </p>
    </example>
 
 
    <p permid="xgl">Podemos mejorar el <xref ref="algcodes-theorem-single-error"/>. Este teorema nos entrega condiciones sobre la matriz <m>H</m> que nos dicen cuándo el peso mínimo del código formado por el espacio nulo de <m>H</m> es <m>2</m>.  También podemos determinar cuándo la distancia mínima de un código lineal es <m>3</m> examinando la matriz correspondiente.
      </p>
 
    <example xml:id="algcodes-example-check-matrix" permid="zqK">
      <p permid="shX">Si hacemos
        <me permid="cRV">
          H =
          \begin{pmatrix}
          1 &amp; 1 &amp; 1 &amp; 0 \\
          1 &amp; 0 &amp; 0 &amp; 1 \\
          1 &amp; 1 &amp; 0 &amp; 0
          \end{pmatrix}
        </me>
      y queremos determinar si <m>H</m> es la matriz verificadora canónica para un código corrector de un error, es necesario asegurarse que  <m>\Null(H)</m> no contenga ninguna <m>4</m>-tupla de peso <m>2</m>. Es decir, <m>(1100)</m>, <m>(1010)</m>, <m>(1001)</m>, <m>(0110)</m>, <m>(0101)</m>, y <m>(0011)</m> no deben estar en <m>\Null(H)</m>.  El próximo teorema establece que podemos saber si el código determinado por  <m>H</m> es corrector de errores examinando las columnas de <m>H</m>. Note en este ejemplo que no solo <m>H</m> no tiene columnas nulas, sino que tampoco tiene columnas repetidas.
      </p>
    </example>
 
    <theorem permid="xBx">
      <statement>
        <p permid="Iwo">Sea <m>H</m> una matriz binaria. El espacio nulo de <m>H</m> es un código corrector de un error si <m>H</m> no contiene columnas de puros ceros ni dos columnas de <m>H</m> son iguales.
      </p>
      </statement>
      <proof permid="Nup">
        <p permid="SVt">La <m>n</m>-tupla <m>{\mathbf e}_{i} +{\mathbf e}_{j}</m> tiene <m>1</m>s en la posiciones <m>i</m>-ésima y <m>j</m>-ésima y ceros en las demás, y <m>w( {\mathbf e}_{i} +{\mathbf e}_{j}) = 2</m> para <m>i \neq j</m>. Como
          <me permid="IZe">{\mathbf 0} = H({\mathbf e}_{i} +{\mathbf e}_{j}) = H{\mathbf e}_{i} + H{\mathbf e}_{j}</me>
        Solo puede ocurrir si la <m>i</m>-ésima y la <m>j</m>-ésima columnas son idénticas. Como no contiene palabras de peso menor o igual a 2, el espacio nulo de <m>H</m> es un código corrector de un error.
      </p>
      </proof>
    </theorem>
 
    <p permid="dnu">Supongamos ahora que tenemos una matriz verificadora canónica <m>H</m> con tres filas. Nos podemos preguntar cuántas columnas le podemos agregar a la matriz y seguir teniendo un espacio nulo que sea un código que detecte y corrija un error. Como cada columna tiene tres entradas, hay <m>2^3 = 8</m> columnas diferentes posibles. No podemos agregar las columnas
      <me permid="pgn">
        \begin{pmatrix}
        0 \\ 0 \\ 0 
        \end{pmatrix},
        \begin{pmatrix}
        1 \\ 0 \\ 0 
        \end{pmatrix},
        \begin{pmatrix}
        0 \\ 1 \\ 0 
        \end{pmatrix},
        \begin{pmatrix}
        0 \\ 0 \\ 1 
        \end{pmatrix}
      </me>.
    Podemos entonces agregar hasta cuatro columnas manteniendo una distancia mínima de <m>3</m>.
      </p>
 
    <p permid="JuD">En general, si <m>H</m> es una matriz verificadora canónica de <m>m \times n</m>, entonces hay <m>n-m</m> posiciones de información en cada palabra del código. Cada columna tiene <m>m</m> bits, así es que hay <m>2^m</m> posibles columnas diferentes. Es necesario que las columnas <m>{\mathbf 0}, {\mathbf e}_1, \ldots, {\mathbf e}_m</m> sean excluidas, dejando <m>2^m - (1 + m)</m> columnas restantes para información si queremos mantener la habilidad de no solo detectar sino también corregir un error.
      </p>
<!-- typo correction.  Suggested by G. Cheng. -->
<!-- TWJ - 10/1/2014 -->

  </section>

  <section xml:id="algcodes-section-efficient-decoding" permid="eef">
    <title>Decodificación Eficiente</title>

    <introduction permid="khM">
 
      <p permid="tXk">Estamos ahora en el punto donde somos capaces de generar códigos lineales que detecten y corrijan errores con relativa facilidad, pero aún es un proceso lento el de decodificar una <m>n</m>-tupla recibida y determinar cuál es la palabra del código más cercana, pues la <m>n</m>-tupla recibida debe ser comparada con todas las posibles palabras del código para determinar la decodificación apropiada. Este puede ser un impedimento serio si el código es muy grande.
      </p>

      <example xml:id="algcodes-example-syndrome" permid="fxT">
        <p permid="Ypg">Dada la matriz binaria
          <me permid="Vnw">
            H =
            \begin{pmatrix}
            1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
          </me>
        y las <m>5</m>-tuplas <m>{\mathbf x} = (11011)^\transpose</m> y <m>{\mathbf y} = (01011)^\transpose</m>, podemos calcular
          <me permid="BuF">
            H{\mathbf x} =
            \begin{pmatrix}
            0 \\ 0 \\ 0 
            \end{pmatrix}
            \qquad
            \text{and}
            \qquad
            H{\mathbf y} =
            \begin{pmatrix}
            1 \\ 0 \\ 1 
            \end{pmatrix}
          </me>.
        Luego, <m>{\mathbf x}</m> es una palabra del código e <m>{\mathbf y}</m> no lo es, pues <m>{\mathbf x}</m> está en el espacio nulo e <m>{\mathbf y}</m> no lo está. Notemos que <m>H{\mathbf y}</m> es idéntica a la primera columna de <m>H</m>. De hecho, es ahí donde ocurrió el error. Si cambiamos el primer bit en <m>{\mathbf y}</m> de <m>0</m> a <m>1</m>, obtenemos <m>{\mathbf x}</m>.
      </p>
      </example>

<!-- typo correction.  Suggested by E. Martin. -->
<!-- TWJ - 1/2/2013 -->
 
      <p permid="aet">Si <m>H</m> es una matriz de <m>m \times n</m> y <m>{\mathbf x} \in {\mathbb Z}_2^n</m>, entonces decimos que el <term>síndrome</term><idx><h>Síndrome de un código</h></idx> de <m>{\mathbf x}</m> es <m>H{\mathbf x}</m>. La siguiente proposición permite la detección y corrección rápida de errores.
      </p>
   
      <proposition xml:id="algcodes-proposition-syndrome" permid="pWY">
        <statement>
          <p permid="gYY">Sea <m>H</m> una matriz de <m>m \times n</m> que determina un código lineal y sea <m>{\mathbf x}</m> la <m>n</m>-tupla recibida. Escribamos <m>{\mathbf x}</m> como <m>{\mathbf x} =  {\mathbf c} +{\mathbf e}</m>, donde <m>{\mathbf c}</m> es la palabra transmitida y <m>{\mathbf e}</m> es el error de transmisión. Entonces el síndrome <m>H{\mathbf x}</m> de la palabra recibida <m>{\mathbf x}</m> es igual al síndrome del error <m>{\mathbf e}</m>.
      </p>
        </statement>
        <proof permid="tBy">
          <p permid="zcC">La demostración sigue del hecho que 
            <me permid="hBO">H{\mathbf x} = H({\mathbf c} +{\mathbf e}) = H{\mathbf c} + H{\mathbf e} = {\mathbf 0} + H{\mathbf e} = H{\mathbf e}</me>.
    </p>
        </proof>
      </proposition>
<!--Made the proof into a complete sentence.  TWJ 3/6/2014-->
 
      <p permid="GlC">Esta proposición nos dice que el síndrome de una palabra recibida depende solamente del error y no de la palabra trasmitida. La demostración del siguiente teorema sigue inmediatamente de la <xref ref="algcodes-proposition-syndrome"/> y del hecho que <m>H{\mathbf e}</m> es la <m>i</m>-ésima columna de la matriz <m>H</m>.
      </p>
 
      <theorem permid="dIG">
        <statement>
          <p permid="oDx">Sea <m>H \in {\mathbb M}_{ m \times n} ( {\mathbb Z}_2)</m> y supongamos que el código lineal correspondiente a <m>H</m> es corrector de un error. Sea <m>{\mathbf r}</m> una <m>n</m>-tupla recibida que fue trasmitida con a lo más un error. Si el síndrome de <m>{\mathbf r}</m> es <m>{\mathbf 0}</m>, entonces no ha ocurrido ningún error; de lo contrario, si el síndrome de <m>{\mathbf r}</m> es igual a alguna columna de <m>H</m>, digamos la <m>i</m>-ésima columna, entonces el error ocurrió en el <m>i</m>-ésimo bit.
      </p>
        </statement>
      </theorem>
   
      <example xml:id="algcodes-example-detecting-errors" permid="LFc">
        <p permid="Ewp">Consideremos la matriz
          <me permid="NIX">
            H =
            \begin{pmatrix}
            1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
          </me>
        y supongamos que las <m>6</m>-tuplas <m>{\mathbf x} = (111110)^\transpose</m>, <m>{\mathbf y} = (111111)^\transpose</m>, y <m>{\mathbf z} = (010111)^\transpose</m> fueron recibidas. Entonces  
          <me permid="tQg">
            H{\mathbf x} =
            \begin{pmatrix}
            1 \\ 1 \\ 1 
            \end{pmatrix},
            H{\mathbf y} =
            \begin{pmatrix}
            1 \\ 1 \\ 0 
            \end{pmatrix},
            H{\mathbf z} =
            \begin{pmatrix}
            1 \\ 0 \\ 0
            \end{pmatrix}
          </me>.
        Luego, <m>{\mathbf x}</m> tiene un error en el tercer bit y <m>{\mathbf z}</m> tiene un error en el cuarto bit. Las palabras trasmitidas para <m>{\mathbf x}</m> y <m>{\mathbf z}</m> deben haber sido <m>(110110)</m> y <m>(010011)</m>, respectivamente. El síndrome de <m>{\mathbf y}</m> no aparece en ninguna de las columnas de <m>H</m>, de manera que más de un error debe haber ocurrido para producir <m>{\mathbf y}</m>.
      </p>
      </example>

    </introduction>

    <subsection xml:id="algcodes-subsection-coset-decoding" permid="oDk">
      <title>Decodificación por Clases Laterales</title>
   
      <p permid="tBL">Podemos usar teoría de grupos para obtener otro método de decodificación.  Un código lineal <m>C</m> es un subgrupo de <m>{\mathbb Z}_2^n</m>. Decodificación <term>por Clases Laterales</term><idx><h>Decodificación por Clases Laterales</h></idx> o <term>decodificación estándar</term><idx><h>Decodificación estándar</h></idx> usa las clases laterales de <m>C</m> en <m>{\mathbb Z}_2^n</m> para implementar la decodificación de probabilidad máxima. Supongamos que <m>C</m> un código lineal <m>(n,m)</m>. Una clase lateral de <m>C</m> en <m>{\mathbb Z}_2^n</m> se escribe en la forma <m>{\mathbf x} + C</m>, donde <m>{\mathbf x} \in {\mathbb Z}_2^n</m>. Por el Teorema de Lagrange (<xref ref="cosets-theorem-lagrange"/>), hay <m>2^{n-m}</m> clases laterales de <m>C</m> en <m>{\mathbb Z}_2^n</m>.
      </p>

      <example xml:id="algcodes-example-coset-decoding" permid="MaB">
        <p permid="kDy">Sea <m>C</m> el código lineal <m>(5,3)</m> dado por la matriz verificadora
          <me permid="ZXp">
            H =
            \begin{pmatrix}
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
            1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
          </me>.
        El código consiste de las palabras
          <me permid="Gey">(00000) \quad (01101) \quad (10011) \quad (11110)</me>.
        Hay <m>2^{5-2} = 2^3</m> clases laterales de <m>C</m> en <m>{\mathbb Z}_2^5</m>, cada una de orden <m>2^2 =4</m>.  Estas clases laterales aparecen en la <xref ref="algcodes-table-cosets-of-c"/>.
      </p>
      </example>
      
      <table xml:id="algcodes-table-cosets-of-c" permid="tuH">
        <title>Representante<m>C</m></title>
         <tabular halign="center" top="medium" permid="FIZ">
          <row>
            <cell>Coset</cell>
            <cell>Coset</cell>
          </row>
          <row bottom="medium">
            <cell>de la clase</cell>
            <cell/>
          </row>
          <row>
            <cell><m>C</m></cell>
            <cell><m>(00000)  (01101)  (10011)  (11110)</m></cell>
          </row>
          <row>
            <cell><m>(10000) + C</m></cell>
            <cell><m>(10000)  (11101)  (00011)  (01110)</m></cell>
          </row>
          <row>
            <cell><m>(01000) + C</m></cell>
            <cell><m>(01000)  (00101)  (11011)  (10110)</m></cell>
          </row>
          <row>
            <cell><m>(00100) + C</m></cell>
            <cell><m>(00100)  (01001)  (10111)  (11010)</m></cell>
          </row>
          <row>
            <cell><m>(00010) + C</m></cell>
            <cell><m>(00010)  (01111)  (10001)  (11100)</m></cell>
          </row>
          <row>
            <cell><m>(00001) + C</m></cell>
            <cell><m>(00001)  (01100)  (10010)  (11111)</m></cell>
          </row>
          <row>
            <cell><m>(10100) + C</m></cell>
            <cell><m>(00111)  (01010)  (10100)  (11001)</m></cell>
          </row>
          <row bottom="medium">
            <cell><m>(00110) + C</m></cell>
            <cell><m>(00110)  (01011)  (10101)  (11000)</m></cell>
          </row>
        </tabular>
      </table>

      <p permid="ZIU">Nuestra tarea es descubrir cómo conocer las clases laterales nos puede ayudar a decodificar un mensaje. Supongamos que <m>{\mathbf x}</m> era la palabra trasmitida y que <m>{\mathbf r}</m> es la <m>n</m>-tupla recibida. Si <m>{\mathbf e}</m> es el error de trasmisión, entonces <m>{\mathbf r} = {\mathbf e} + {\mathbf x}</m> o, equivalentemente, <m>{\mathbf x} = {\mathbf e} + {\mathbf r}</m>. Pero, esto es exactamente equivalente a decir que <m>{\mathbf r}</m> es un elemento de la clase <m>{\mathbf e} + C</m>. En la decodificación de máxima probabilidad esperamos que <m>{\mathbf e}</m> sea lo más pequeño que se pueda; es decir, <m>{\mathbf e}</m> tendrá el menor peso. Una <m>n</m>-tupla de peso mínimo en una clase se denomina <idx><h>Líder</h><h>de clase</h></idx><term>líder de clase</term>. Una vez que hemos determinado un líder para cada clase, el proceso de decodificación se transforma en el de calcular <m>{\mathbf r} + {\mathbf e}</m> para obtener <m>{\mathbf x}</m>.
      </p>

      <example xml:id="algcodes-example-representative" permid="shK">
        <p permid="QKH">En la <xref ref="algcodes-table-cosets-of-c"/>, note que hemos elegido un representante de peso mínimo para cada clase.  Estos representantes son líderes de clase. Ahora supongamos que recibimos la palabra <m>{\mathbf r} = (01111)</m>. Para decodificar <m>{\mathbf r}</m>, lo encontramos en la clase <m>(00010) + C</m>; luego, la palabra del código originalmente trasmitida debe haber sido <m>(01101) = (01111) + (00010)</m>.
      </p>
      </example>
   
      <p permid="FQd">Un problema potencial con este método de decodificación es que tengamos que examinar cada clase en busca de la palabra recibida. La siguiente proposición entrega un método para la implementación de la decodificación por clases laterales. Establece que podemos asociar un síndrome con cada clase; luego, podemos hacer una tabla que asigna un líder de clase a cada síndrome. Tal lista se denomina <idx><h>Tabla de decodificación</h></idx><term>tabla de decodificación</term>.
      </p>
   
      <table xml:id="algcodes-table-syndrome" permid="ZBQ">
        <title>Síndromes para cada clase</title>
         <tabular halign="center" top="medium" permid="lQi">
          <row bottom="medium">
            <cell>Síndrome</cell>
            <cell>Líder de clase</cell>
          </row>
          <row>
            <cell><m>(000)</m></cell>
            <cell><m>(00000)</m></cell>
          </row>
          <row>
            <cell><m>(001)</m></cell>
            <cell><m>(00001)</m></cell>
          </row>
          <row>
            <cell><m>(010)</m></cell>
            <cell><m>(00010)</m></cell>
          </row>
          <row>
            <cell><m>(011)</m></cell>
            <cell><m>(10000)</m></cell>
          </row>
          <row>
            <cell><m>(100)</m></cell>
            <cell><m>(00100)</m></cell>
          </row>
          <row>
            <cell><m>(101)</m></cell>
            <cell><m>(01000)</m></cell>
          </row>
          <row>
            <cell><m>(110)</m></cell>
            <cell><m>(00110)</m></cell>
          </row>
          <row bottom="medium">
            <cell><m>(111)</m></cell>
            <cell><m>(10100)</m></cell>
          </row>
        </tabular>
      </table>
       
      <proposition permid="fTs">
        <statement>
          <p permid="Ngh">Sea <m>C</m> un código lineal <m>(n,k)</m> dado por la matriz <m>H</m> y supongamos que <m>{\mathbf x}</m> e <m>{\mathbf y}</m> están en <m>{\mathbb Z}_2^n</m>. Entonces <m>{\mathbf x}</m> e <m>{\mathbf y}</m> están en la misma clase lateral de <m>C</m> si y solo si <m>H{\mathbf x} = H{\mathbf y}</m>. Es decir, dos <m>n</m>-tuplas están en la misma clase lateral si y solo si tienen el mismo síndrome.
      </p>
        </statement>
        <proof permid="ZIH">
          <p permid="fjL">Dos <m>n</m>-tuplas <m>{\mathbf x}</m> e <m>{\mathbf y}</m> están en la misma clase lateral de <m>C</m> precisamente cuando <m>{\mathbf x} - {\mathbf y} \in C</m>; pero, esto es equivalente a que <m>H({\mathbf x} - {\mathbf y}) = 0</m> o <m>H {\mathbf x} = H{\mathbf y}</m>.
      </p>
        </proof>
      </proposition>
   
      <example xml:id="algcodes-example-decoding-table" permid="YoT">
        <p permid="wRQ">La <xref ref="algcodes-table-syndrome"/> es una tabla de decodificación para el código <m>C</m> dado en el <xref ref="algcodes-example-coset-decoding"/>. Si se recibe <m>{\mathbf x} = (01111)</m>, entonces su síndrome se calcula como
          <me permid="mlH">
            H {\mathbf x} =
            \begin{pmatrix}
            0 \\ 1 \\ 0
            \end{pmatrix}
          </me>.
        Examinando la tabla de decodificación, determinamos que el líder de clase es <m>(00010)</m>. Es fácil ahora decodificar la palabra recibida.
      </p>
      </example>
   
      <p permid="lXm">Dado un código de bloque <m>(n,k)</m>, surge la pregunta si la decodificación por clases laterales es un sistema manejable o no.  Una tabla de decodificación requiere una lista de líderes de clases laterales y síndromes uno para cada una de las <m>2^{n - k}</m> clases laterales de <m>C</m>.  Supongamos que tenemos un código de bloque <m>(32, 24)</m>.  Tenemos una enorme cantidad de palabras en el código, <m>2^{24}</m>, pero hay solamente <m>2^{32 - 24} = 2^{8} = 256</m> clases laterales.
      </p>

      <paragraphs component="sage-blurb" permid="FBv">
        <title>Sage</title>
        
        <p permid="Sev">Sage tiene bastantes comandos para teoría de códigos, incluyendo la capacidad de construir diferentes familias de códigos.
      </p>
      </paragraphs>

    </subsection>
   </section>
 
 <reading-questions permid="gmA">

    <exercise permid="nCe">
      <statement>
        <p permid="slX">
          Supongamos que un código binario tiene una distancia mínima <m>d=6</m>.
¿Cuántos errores se pueden detectar?
¿Cuántos errores se pueden corregir?
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="TJn">
      <statement>
        <p permid="Ytg">
          Explique por qué es imposible que la cadena de 8 bits con valor decimal <m>56_{10}</m> sea un código <acro>ASCII</acro> para un carácter.
Supongamos que el bit más a la izquierda de la cadena se utiliza como bit de verificación de paridad.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="zQw">
      <statement>
        <p permid="EAp">
          Supongamos que recibimos la cadena de 8 bits con valor decimal <m>56_{10}</m> cuando esperamos caracteres <acro>ASCII</acro> con un bit de verificación de paridad en el primer bit
(el de más a la izquierda).
Sabemos que ha ocurrido un error en la transmisión.
Proporcione una de las conjeturas probables para el carácter que realmente se envió
(aparte de <sq>8</sq>),
bajo el supuesto de que cualquier bit individual rara vez se envía por error.
Explique la lógica de su respuesta.
(Es posible que deba consultar una tabla de valores <acro>ASCII</acro> en línea).
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="fXF">
      <statement>
        <p permid="kHy">
          Supongamos que se crea un código lineal <m>C</m> como el espacio nulo de la matriz de verificación de paridad
          <me permid="wVQ">
            H =\begin{bmatrix}
            0 \amp 1 \amp 0 \amp 1 \amp 0 \\
            1 \amp 1 \amp 1 \amp 1 \amp 0 \\
            0 \amp 0 \amp 1 \amp 1 \amp 1
            \end{bmatrix}
          </me>
          Entonces <m>x=11100</m> no es una palabra del código.
Describa un cálculo y muestre el resultado de ese cálculo,
para verificar que <m>x</m> no es una palabra del código <m>C</m>.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="MeO">
      <statement>
        <p permid="QOH">
          Para <m>H</m> y <m>x</m> como en la pregunta anterior,
suponga que <m>x</m> se recibe como un mensaje.
Dé una decodificación de máxima verosimilitud para el mensaje recibido.
        </p>
      </statement>
      <response/>
    </exercise>

  </reading-questions>

   <exercises xml:id="algcodes-exercises" filenamebase="algcodes" permid="NfU">
    <title>Ejercicios</title>
  
    <exercise number="1" permid="kDl" xml:id="algcodes-exercise-acceptable-codes">
      <statement>
        <p permid="SzU">¿Por qué no es aceptable el siguiente sistema de codificación?</p>
  
        <tabular halign="center" top="medium" permid="AZg">
          <row bottom="medium">
            <cell>Información</cell>
            <cell><m>0</m></cell>
            <cell><m>1</m></cell>
            <cell><m>2</m></cell>
            <cell><m>3</m></cell>
            <cell><m>4</m></cell>
            <cell><m>5</m></cell>
            <cell><m>6</m></cell>
            <cell><m>7</m></cell>
            <cell><m>8</m></cell>
          </row>
          <row bottom="medium">
            <cell>palabra del código</cell>
            <cell><m>000</m></cell>
            <cell><m>001</m></cell>
            <cell><m>010</m></cell>
            <cell><m>011</m></cell>
            <cell><m>101</m></cell>
            <cell><m>110</m></cell>
            <cell><m>111</m></cell>
            <cell><m>000</m></cell>
            <cell><m>001</m></cell>
          </row>
        </tabular>
        
      </statement>
      
    </exercise>
  
    <exercise number="2" permid="QKu" xml:id="algcodes-exercise-not-a-group-code">
      <statement>
        <p permid="yHd">Sin realizar ninguna suma, explique por qué el siguiente conjunto de <m>4</m>-tuplas en <m>{\mathbb Z}_2^4</m> no puede ser un código de grupo. 
          <me permid="SsQ">(0110) \quad (1001) \quad (1010) \quad (1100)</me></p>
      </statement>
      <hint permid="esA">
        <p permid="HMu">No puede ser un código de grupos pues <m>(0000) \notin C</m>.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="3" permid="wRD" xml:id="algcodes-exercise-hamming-distance">
      <statement>
        <p permid="eOm">Calcule las distancias de Hamming entre las siguientes pares de <m>n</m>-tuplas.
          <ol cols="2" permid="AKy">
  
            <li permid="HjE"><p permid="ZBD"><m>(011010), (011100)</m></p></li>
  
            <li permid="nqN"><p permid="FIM"><m>(11110101), (01010100)</m></p></li>
  
            <li permid="TxW"><p permid="lPV"><m>(00110), (01111)</m></p></li>
  
            <li permid="zFf"><p permid="RXe"><m>(1001), (0111)</m></p></li>
  
          </ol></p>
      </statement>
      <hint permid="qGS">
        <p permid="nTD">(a) <m>2</m>; (c) <m>2</m>.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="4" permid="cYM" xml:id="algcodes-exercise-weights">
      <statement>
        <p permid="KVv">Calcule los pesos de las siguientes <m>n</m>-tuplas.
          <ol cols="2" permid="gRH">
  
            <li permid="fMo"><p permid="yen"><m>(011010)</m></p></li>
  
            <li permid="LTx"><p permid="elw"><m>(11110101)</m></p></li>
  
            <li permid="saG"><p permid="KsF"><m>(01111)</m></p></li>
  
            <li permid="YhP"><p permid="qzO"><m>(1011)</m></p></li>
  
          </ol></p>
      </statement>
      <hint permid="CVk">
        <p permid="UaM">(a) <m>3</m>; (c) <m>4</m>.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="5" permid="JfV" xml:id="algcodes-exercise-minimum-weight-7">
      <statement>
        <p permid="rcE">Si un código lineal <m>C</m> tiene peso mínimo <m>7</m>, ¿cuáles son las capacidades de detección y corrección de errores de  <m>C</m>?</p>
      </statement>
      
    </exercise>
  
    <exercise number="6" permid="pne" xml:id="algcodes-exercise-minimum-distance">
      <statement>
        <p permid="XjN">Para cada uno de los siguientes códigos, ¿cuál es la distancias mínima del código? ¿Cuál es la mejor situación que podemos esperar en relación a detección y corrección de errores? 
          <ol permid="MYQ">
            <li permid="EoY">
              <p permid="WGX">
                <m>(011010) \; (011100) \; (110111) \; (110000)</m>
              </p>
            </li>

            <li permid="kwh">
              <p permid="COg">
                <m>(011100) \; (011011) \; (111011) \; (100011) \\ (000000) \; (010101) \; (110100) \; (110011)</m>
              </p>
            </li>

            <li permid="QDq">
              <p permid="iVp">
                <m>(000000) \; (011100) \; (110101) \; (110001)</m>
              </p>
            </li>

            <li permid="wKz">
              <p permid="Pcy">
                <m>(0110110) \; (0111100) \; (1110000) \; (1111111) \\ (1001001) \; (1000011) \; (0001111) \; (0000000)</m>
              </p>
            </li>
          </ol></p>
      </statement>
      <hint permid="vqL">
        <p permid="AhV">(a) <m>d_{\min} = 2</m>; (c) <m>d_{\min} = 1</m>.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="7" permid="Vun" xml:id="algcodes-exercise-null-space">
      <statement>
        <p permid="DqW">Calcule el espacio nulo de cada una de las siguientes matrices.  ¿Qué tipo de códigos de bloque <m>(n,k)</m> son los espacios nulos? ¿Puede encontrar una matriz (no necesariamente una matriz generadora estándar) que genere cada código? ¿Son únicas sus matrices generadoras?
          <ol cols="2" permid="tfZ">
  
            <li permid="cRI"><p permid="vjH"><me permid="yzZ">\begin{pmatrix}
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
            1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
            \end{pmatrix}</me></p></li>
  
            <li permid="IYR"><p permid="bqQ"><me permid="eHi">\begin{pmatrix}
            1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}</me></p></li>
  
            <li permid="pga"><p permid="HxZ"><me permid="KOr">\begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
            0 &amp; 1 &amp; 0 &amp; 1 &amp; 1
            \end{pmatrix}</me></p></li>
  
            <li permid="Vnj"><p permid="nFi"><me permid="qVA">\begin{pmatrix}
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
            1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1
            \end{pmatrix}</me></p></li>
  
          </ol></p>
      </statement>
      <hint permid="HFd">
        <p permid="gpe"><ol permid="owg">
         
          <li permid="Bus"><p permid="TMr"><m>(00000), (00101), (10011), (10110)</m>
            <me permid="XcJ">G = 
            \begin{pmatrix}
            0 &amp; 1 \\
            0 &amp; 0 \\
            1 &amp; 0 \\
            0 &amp; 1 \\
            1 &amp; 1
            \end{pmatrix}</me></p></li>
           
          <li permid="hBB"><p permid="zTA"><m>(000000), (010111), (101101), (111010)</m>
            <me permid="DjS">G = 
            \begin{pmatrix}
            1 &amp; 0 \\
            0 &amp; 1 \\
            1 &amp; 0 \\
            1 &amp; 1 \\ 
            0 &amp; 1 \\
            1 &amp; 1
            \end{pmatrix}</me></p></li>
         
        </ol></p>
      </hint>
      
    </exercise>
  
    <exercise number="8" permid="BBw" xml:id="algcodes-exercise-5-2-block-code">
      <statement>
        <p permid="jyf">Construya un código de bloque <m>(5,2)</m>. Discuta las capacidades de detección y corrección de errores de su código.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="9" permid="hIF" xml:id="algcodes-exercise-null-space-code">
      <statement>
        <p permid="PFo">Sea <m>C</m> el código obtenido como espacio nulo de la matriz
          <me permid="oaU">H =
          \begin{pmatrix}
          0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 1
          \end{pmatrix}</me>.
        Decodifique el mensaje
          <me permid="Uid">01111 \quad 10101 \quad 01110 \quad 00011</me>
        si es posible.
      </p>
      </statement>
      <hint permid="AaE">
        <p permid="Mwn">Múltiples errores ocurren en una de las palabras recibidas.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="10" permid="NPO" xml:id="algcodes-exercise-probability">
      <statement>
        <p permid="vMx">Supongamos que se transmite un mensaje binario de <m>1000</m> bits, que la probabilidad de error en un bit es <m>p</m> y que los errores que puedan ocurrir en bits diferentes son independientes entre ellos. Si <m>p = 0.01</m>, ¿Cuál es la probabilidad de que ocurra más de un error? ¿Cuál es la probabilidad de que ocurran exactamente dos errores?  Repita el problema para <m>p = 0.0001</m>.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="11" xml:id="algcodes-exercise-check-matrices" permid="tWX">
      <statement>
        <p permid="bTG">¿Qué matrices son matrices verificadoras canónicas? Para aquella matrices que sean matrices verificadoras canónicas, ¿cuáles son las correspondientes matrices generadoras estándar? ¿Cuáles son las capacidades de detección y corrección de errores de cada una de  estas matrices?
          <ol cols="2" permid="Zni">
  
            <li permid="mlu"><p permid="EDt"><me permid="Apm">\begin{pmatrix}
            1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}</me></p></li>
  
            <li permid="SsD"><p permid="kKC"><me permid="gwv">\begin{pmatrix}
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}</me></p></li>
  
            <li permid="yzM"><p permid="QRL"><me permid="MDE">\begin{pmatrix}
            1 &amp; 1 &amp; 1 &amp; 0 \\
            1 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}</me></p></li>
  
            <li permid="eGV"><p permid="wYU"><me permid="sKN">\begin{pmatrix}
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}</me></p></li>
  
          </ol></p>
      </statement>
      <hint permid="swf">
        <p permid="sDw">(a) Es matriz verificadora canónica con matriz generadora estándar
            <me permid="YRW">G = 
            \begin{pmatrix}
            1 \\ 1 \\ 0 \\ 0 \\ 1
            \end{pmatrix}</me>.
    </p>
  
        <p permid="YKF">(c) Es matriz verificadora canónica con matriz generadora estándar
            <me permid="EZf">G = 
            \begin{pmatrix}
            1 &amp; 0 \\
            0 &amp; 1 \\
            1 &amp; 1 \\
            1 &amp; 0
            \end{pmatrix}</me>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="12" permid="aeg" xml:id="algcodes-exercise-syndromes">
      <statement>
        <p permid="IaP">Liste todos los posible síndromes para los códigos generados por cada una de las matrices del <xref ref="algcodes-exercise-check-matrices"/>.
      </p>
      </statement>
      <hint permid="EKx">
        <p permid="ERO">(a) Ocurren todos los posibles síndromes.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="13" permid="Glp" xml:id="algcodes-exercise-syndrome-transmission-error">
      <statement>
        <p permid="ohY">Sea
          <me permid="JIY">H =
          \begin{pmatrix}
          0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 1
          \end{pmatrix}</me>.
        Calcule el síndrome causado por cada uno de los siguientes errores de transmisión. 
          <ol permid="Fur">
           
            <li permid="jqO"><p permid="BIN">Un error en el primer bit.
      </p></li>
             
            <li permid="PxX"><p permid="hPW">Un error en el tercer bit.
      </p></li>
             
            <li permid="vFg"><p permid="NXf">Un error en el último bit.
      </p></li>
             
            <li permid="bMp"><p permid="ueo">Errores en el tercer y cuarto bits.
      </p></li>
           
          </ol></p>
      </statement>
      
    </exercise>
  
    <exercise number="14" permid="msy" xml:id="algcodes-exercise-cosets-Z8">
      <statement>
        <p permid="Uph">Sea <m>C</m> el código de grupo en <m>{\mathbb Z}_2^3</m> definido por las palabras <m>(000)</m> y <m>(111)</m>. Calcule las clases laterales de <m>C</m> en <m>{\mathbb Z}_2^3</m>. ¿Por qué no es necesario especificar si se trata de clases laterales derechas o izquierdas? Entregue el error singular de transmisión, si lo hay, que corresponda con cada clase lateral.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="15" permid="SzH" xml:id="algcodes-exercise-find-cosets">
      <statement>
      <p permid="Awq">Para cada una de las siguientes matrices, encuentre las clases laterales para el código <m>C</m> correspondiente. Entregue una tabla de decodificación para cada código si es posible.
        <ol cols="2" permid="lBA">
  
          <li permid="HTy"><p permid="alx"><me permid="VXq">\begin{pmatrix}
          0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
          \end{pmatrix}</me></p></li>
  
          <li permid="oaH"><p permid="GsG"><me permid="Cez">\begin{pmatrix}
          0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
          1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
          0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
          \end{pmatrix}</me></p></li>
  
          <li permid="UhQ"><p permid="mzP"><me permid="ilI">\begin{pmatrix}
          1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
          0 &amp; 1 &amp; 0 &amp; 1 &amp; 1
          \end{pmatrix}</me></p></li>
  
          <li permid="AoZ"><p permid="SGY"><me permid="OsR">\begin{pmatrix}
          1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
          1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
          \end{pmatrix}</me></p></li>
  
        </ol></p>
      </statement>
      <hint permid="dnh">
        <p permid="kYX">(a) <m>C</m>, <m>(10000) + C</m>, <m>(01000) + C</m>, <m>(00100) + C</m>, <m>(00010) + C</m>, <m>(11000) + C</m>, <m>(01100) + C</m>, <m>(01010) + C</m>.  No hay tabla de decodificación para <m>C</m> pues este es solo un código detector de un error.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="16" permid="yGQ" xml:id="algcodes-exercise-proof-distance">
      <statement>
        <p permid="gDz">Sean <m>{\mathbf x}</m>, <m>{\mathbf y}</m>, y <m>{\mathbf z}</m>  <m>n</m>-tuplas binarias. Demuestre cada uno de los siguientes enunciados. 
          <ol permid="RIJ">
           
            <li permid="EYS"><p permid="XqR"><m>w({\mathbf x}) = d( {\mathbf x}, {\mathbf 0})</m></p></li>
             
            <li permid="lgb"><p permid="Dya"><m>d( {\mathbf x}, {\mathbf y}) = d( {\mathbf x} + {\mathbf z}, {\mathbf y} + {\mathbf z} )</m></p></li>
             
            <li permid="Rnk"><p permid="jFj"><m>d({\mathbf x}, {\mathbf y}) = w({\mathbf x}- {\mathbf y})</m></p></li>
           
          </ol></p>
      </statement>
      
    </exercise>
  
    <exercise number="17" permid="eNZ" xml:id="algcodes-exercise-metric">
      <statement>
        <p permid="MKI">Una <term>métrica</term> en un conjunto <m>X</m> es una función <m>d: X \times X \rightarrow {\mathbb R}</m> que satisface las siguientes condiciones. 
          <ol permid="xPS">
       
            <li permid="xut"><p permid="vTB"><m>d( {\mathbf x}, {\mathbf y}) \geq 0</m> para todo <m>{\mathbf x}, {\mathbf y} \in X</m>;</p></li>
       
            <li permid="dBC"><p permid="caK"><m>d( {\mathbf x}, {\mathbf y}) = 0</m> si y solo si <m>{\mathbf x} = {\mathbf y}</m>;</p></li>
       
            <li permid="JIL"><p permid="IhT"><m>d( {\mathbf x}, {\mathbf y})= d( {\mathbf y}, {\mathbf x})</m>;</p></li>
       
            <li permid="pPU"><p permid="opc"><m>d( {\mathbf x}, {\mathbf y}) \leq d( {\mathbf x}, {\mathbf z}) + d( {\mathbf z}, {\mathbf y})</m>.
      </p></li>
       
          </ol>En otros palabras, una métrica es simplemente una generalización de la noción de distancia. Demuestre que la distancia de Hamming es una métrica en <m>{\mathbb Z}_2^n</m>. Decodificar un mensaje en realidad corresponde a decidir cuál es la palabra del código más cercana en términos de la distancia de Hamming.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="18" permid="KVi" xml:id="algcodes-exercise-i-th-coordinate">
      <statement>
        <p permid="sRR">Sea <m>C</m> un código lineal binario. Muestre que entre las <m>i</m>-ésimas coordenadas de la palabras en <m>C</m> hay puros ceros o exactamente la mitad son ceros.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="19" permid="rcr" xml:id="algcodes-exercise-even-weight">
      <statement>
        <p permid="YZa">Sea <m>C</m> un código lineal binario. Muestre que ya sea todas las palabras tienen peso par o exactamente la mitad de ellas tienen peso par.
      </p>
      </statement>
      <hint permid="hXa">
        <p permid="Rgg">Sea <m>{\mathbf x} \in C</m> una palabra de peso impar y defina una función y defina una función del conjunto de todas las palabras de peso impar al conjunto de las palabras de peso par como <m>{\mathbf y} \mapsto {\mathbf x} + {\mathbf y}</m>. Muestre que esta función es una biyección.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="20" permid="XjA" xml:id="algcodes-exercise-even-weight-linear-code">
      <statement>
        <p permid="Fgj">Muestre que las palabras de peso par en un código lineal binario <m>C</m> también forman un código lineal.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="21" permid="DqJ" xml:id="algcodes-exercise-ascii-characters">
      <statement>
        <p permid="lns">Si hemos de usar un código lineal corrector de errores para transmitir los 128 caracteres <acro>ASCII</acro>, ¿qué tamaño de matriz debe usarse? ¿Qué tamaño de matriz debe usarse para transmitir el conjunto <acro>ASCII</acro> extendido de 256 caracteres?  ¿Y si solo requerimos detección de errores en ambos casos?</p>
      </statement>
      
    </exercise>
  
    <exercise number="22" permid="jxS" xml:id="algcodes-exercise-canonical-parity-check-matrix">
      <statement>
        <p permid="RuB">Encuentre la matriz verificadora canónica que da el código de verificación de paridad con tres posiciones de información. ¿Cuál es la matriz para siete posiciones de información?  ¿Cuáles son las matrices generadoras estándar correspondientes?</p>
      </statement>
      
    </exercise>
  
    <exercise number="23" permid="PFb" xml:id="algcodes-exercise-20-information-positions">
      <statement>
        <p permid="xBK">¿Cuántas posiciones de verificación se necesitan para un código de corrección de un error con 20 posiciones de información? ¿Con 32 posiciones de información?</p>
      </statement>
      <hint permid="mGT">
        <p permid="xnp">Para <m>20</m> posiciones de información, se requieren al menor 6 bits de verificación para permitir un código de corrección de un error.
      </p>
      </hint>
      
    </exercise>
  
    <exercise number="24" permid="vMk" xml:id="algcodes-exercise-binary-code">
      <statement>
        <p permid="dIT">Sea <m>{\mathbf e}_i</m> la  <m>n</m>-tupla binaria con un <m>1</m> en la <m>i</m>-ésima coordenada y <m>0</m> en las demás y supongamos que  <m>H \in {\mathbb M}_{m \times n}({\mathbb Z}_2)</m>. Muestre que <m>H{\mathbf e}_i</m> es la <m>i</m>-ésima columna de la matriz <m>H</m>. </p>
      </statement>
      
    </exercise>
  
    <exercise number="25" xml:id="algcodes-exercise-dual-code" permid="bTt">
      <statement>
        <p permid="JQc">Sea <m>C</m> un código lineal <m>(n,k)</m>. Definamos el <term>código dual</term> o <term>código ortogonal</term> de <m>C</m> como 
          <me permid="mVB">C^\perp = \{ {\mathbf x} \in {\mathbb Z}_2^n :  {\mathbf x} \cdot {\mathbf y} = 0 \text{ para todo } {\mathbf y} \in C \}</me>.
          <ol permid="dXb">
   
            <li permid="VXd"><p permid="Uwl">Encuentre el código dual del código lineal <m>C</m> donde <m>C</m> está dado por la matriz 
              <me permid="TcK">\begin{pmatrix}
              1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
              0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
              1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
              \end{pmatrix}</me>.
    </p></li>
   
            <li permid="Cem"><p permid="ADu">Muestre que <m>C^\perp</m> es un código lineal <m>(n, n-k)</m>.
      </p></li>
   
            <li permid="ilv"><p permid="gKD">Encuentre las matrices verificadora canónica y generadora estándar de <m>C</m> y <m>C^\perp</m>. ¿Qué sucede en general? Demuestre su conjetura.
      </p></li>
   
          </ol></p>
      </statement>
      
    </exercise>
  
    <exercise number="26" permid="IaC" xml:id="algcodes-exercise-hamming-code">
      <statement>
        <p permid="pXl">Sea <m>H</m> una matriz de <m>m \times n</m> sobre <m>{\mathbb Z}_2</m>, donde la <m>i</m>-ésima columna es el número <m>i</m> escrito en binario con <m>m</m> bits. El espacio nulo de una tal matriz se llama <term>código de Hamming</term>. 
          <ol permid="Kek">
   
            <li permid="GOf"><p permid="Fnn">Muestre que la matriz
              <me permid="rFu">H =
              \begin{pmatrix}
              0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
              0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
              1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0
              \end{pmatrix}</me>
          genera un código de Hamming. ¿Cuáles son las propiedades de corrección de errores de un código de Hamming?</p></li>
   
            <li permid="mVo"><p permid="luw">La columna correspondiente al síndrome también marca el bit donde ocurrió el error; es decir, la <m>i</m>-ésima columna de la matriz es <m>i</m> escrito como número binario, y el síndrome inmediatamente nos dice cuál es el bit erróneo. Si la palabra recibida es <m>(101011)</m>, Calcule el síndrome. ¿En qué bit ocurrió el error en este caso, y cuál era la palabra originalmente transmitida?</p></li>
   
            <li permid="Tcx"><p permid="RBF">Entregue un matriz binaria <m>H</m> para el código de Hamming con seis posiciones de informacióny cuatro de verificación. ¿Cuáles son la posiciones de verificación y cuáles son las de información? Codifique los mensajes <m>(101101)</m> y <m>(001001)</m>. Decodifique las palabras recibidas <m>(0010000101)</m> y <m>(0000101100)</m>.  ¿Cuáles son los posibles síndromes para este código?</p></li>
   
            <li permid="zjG"><p permid="xIO">¿Cuál es el número de bits de verificación y el número de bits de información en un código de Hamming de bloque <m>(m,n)</m>? Encuentre tanto una cota superior como una cota inferior para el número de bits de información en términos del número de bits de verificación. Códigos de Hamming que tengan el máximo posible número de bits de información con <m>k</m> bits de verificación se llaman <term>perfectos</term>. Cada posible síndrome a excepción de <m>{\mathbf 0}</m> ocurre como una columna. Si el número de bits de información es menor al máximo, entonces el código se llama <term>recortado</term>. En este caso, dé un ejemplo donde algunos síndromes puedan representar errores múltiples.
      </p></li>
   
          </ol></p>
      </statement>
      
    </exercise>
  
  </exercises>

  <exercises xml:id="algcodes-exercises-programming" permid="tnd">
    <title>Ejercicios de Programación</title>
 
     <exercise permid="ohL">
       <statement>
         <p permid="Weu">Escriba un programa para implementar un código lineal <m>(16, 12)</m>.  Su programa debe ser capaz de codificar y decodificar mensajes usando decodificación por clases laterales. Una vez que haya escrito su programa, escriba un programa para simular un   canal simétrico binario con ruido de trasmisión.  Compare los resultados de su simulación con la probabilidad de error predicha. </p>
       </statement>
     </exercise>

  </exercises>
 
  <references xml:id="algcodes-references" permid="GJf">
  <title>Referencias y Lecturas Recomendadas</title>

    <biblio type="raw" permid="mQo"> <!-- was [1] -->
    Blake, I. F. <q>Codes and Designs,</q> <title>Mathematics Magazine</title> <volume>52</volume>(1979), 81<ndash/>95.
    </biblio>
     
     <!-- Reference updated - TWJ 6/1/2010 -->
    <biblio type="raw" permid="SXx"> <!-- was [2] -->
    Hill, R. <title>A First Course in Coding Theory</title>. Oxford University Press, Oxford, 1990.
    </biblio> 
     
    <biblio type="raw" permid="zeG"> <!-- was [3] -->
    Levinson, N. <q>Coding Theory: A Counterexample to G. H. Hardy's Conception of Applied Mathematics,</q> <title>American Mathematical Monthly</title> <volume>77</volume>(1970), 249<ndash/>58. </biblio>

    <!-- Reference updated - TWJ 6/1/2010 -->
    <biblio type="raw" permid="flP"> <!-- was [4] -->
    Lidl, R. and Pilz, G. <title>Applied Abstract Algebra</title>. 2nd ed. Springer, New York, 1998. </biblio>

    <!-- Reference updated - TWJ 6/1/2010 -->
    <biblio type="raw" permid="LsY"> <!-- was [5] -->
    MacWilliams, F. J. and Sloane, N. J. A. <title>The Theory of Error-Correcting Codes</title>. North-Holland Mathematical Library, 16, Elsevier, Amsterdam, 1983. </biblio>
     
    <biblio type="raw" permid="rAh"> <!-- was [6] -->
    Roman, S. <title>Coding and Information Theory</title>. Springer-Verlag, New York, 1992. </biblio>
     
    <biblio type="raw" permid="XHq"> <!-- was [7] -->
    Shannon, C. E. <q>A Mathematical Theory of Communication,</q> <title>Bell System Technical Journal</title> <volume>27</volume>(1948), 379<ndash/>423, 623<ndash/>56.
    </biblio>
     
    <biblio type="raw" permid="DOz"> <!-- was [8] -->
    Thompson, T. M. <title>From Error-Correcting Codes through Sphere Packing to Simple Groups</title>. Carus Monograph Series, No. 21. Mathematical Association of America, Washington, DC, 1983.
    </biblio> 
     
    <!-- Reference updated - TWJ 6/1/2010 -->
    <biblio type="raw" permid="jVI"> <!-- was [9] -->
    van Lint, J. H. <title>Introduction to Coding Theory</title>. Springer, New York, 1999.
    </biblio>

  </references>
 
  <section xml:id="algcodes-sage" component="sage-info" permid="Klo">
    <title>Sage</title>
    
    <introduction permid="QoV">
      <p permid="msL">Sage contiene una colección importante de códigos lineales y una variedad de métodos que pueden ser usados para investigarlos.
      </p>
    </introduction>
  
    <subsection permid="UKt">
      <title>Construyendo Códigos Lineales</title>
  
      <p permid="ylE">El objeto <c>codes</c> puede ser usado para obtener una lista concisa de los códigos implementados disponibles.  Escriba <c>codes.</c> y presione <c>Tab</c>.  La mayor parte de las interfaces a Sage le entregarán una lista.  Puede usar el signo de interrogación al final del nombre de un método para aprender más sobre los distintos parámetros.
      </p>
  
      <sage doctest="not tested" permid="JyQ">
        <input>codes.</input>
      </sage>
  
      <p permid="esN">Usaremos el código binario de Hamming <m>(7,4)</m> clásico como ilustración.  <q>Binario</q> quiere decir que tenemos vectores con solo ceros y unos, <m>7</m> es el largo y significa que los vectores tienen  <m>7</m> coordenadas, y <m>4</m> es la dimensión, lo que significa que este código contiene <m>2^4=16</m> vectores.   La documentación supone que sabemos unas pocas cosas de más adelante en el texto.  Usamos <c>GF(2)</c> para especificar que el código es binario <mdash/> esto tendrá más sentido después de haber estudiado cuerpos finitos.  Un segundo parámetro es <c>r</c> y podemos ver de las fórmulas en la documentación que poniendo <c>r=3</c> nos dará largo <m>7</m>.
      </p>
  
      <sage permid="pFZ">
        <input>H = codes.HammingCode(GF(2), 3); H</input>
        <output>[7, 4] Hamming Code over GF(2)</output>
      </sage>
    </subsection>
  
    <subsection permid="ARC">
      <title>Propiedades de los Códigos Lineales</title>
  
      <p permid="KzW">Podemos ahora examinar el código que acabamos de construir.  Primero su dimensión.
      </p>
  
      <sage permid="VNi">
        <input>H.dimension()</input>
        <output>4</output>
      </sage>
  
      <p permid="qHf">El código es suficientemente pequeño como para listar todas sus palabras.
      </p>
  
      <sage permid="BUr">
        <input>H.list()</input>
        <output>
        [(0, 0, 0, 0, 0, 0, 0), (1, 0, 0, 0, 0, 1, 1), (0, 1, 0, 0, 1, 0, 1),
         (1, 1, 0, 0, 1, 1, 0), (0, 0, 1, 0, 1, 1, 0), (1, 0, 1, 0, 1, 0, 1),
         (0, 1, 1, 0, 0, 1, 1), (1, 1, 1, 0, 0, 0, 0), (0, 0, 0, 1, 1, 1, 1),
         (1, 0, 0, 1, 1, 0, 0), (0, 1, 0, 1, 0, 1, 0), (1, 1, 0, 1, 0, 0, 1),
         (0, 0, 1, 1, 0, 0, 1), (1, 0, 1, 1, 0, 1, 0), (0, 1, 1, 1, 1, 0, 0),
         (1, 1, 1, 1, 1, 1, 1)]
        </output>
      </sage>
  
      <p permid="WOo">La distancia mínima es posiblemente una de sus propiedades más importantes.  Los códigos de Hamming siempre tienen distancia mínima <m>d=3</m>, de manera que siempre son correctores de un error.
      </p>
  
      <sage permid="ibA">
        <input>H.minimum_distance()</input>
        <output>3</output>
      </sage>
  
      <p permid="CVx">Sabemos que la matriz verificadora y la matriz generadora son útiles para la construcción, descripción y análisis de los códigos lineales.  Los nombres de los métodos en Sage son un poco crípticos.  Sage tienen rutinas para analizar matrices con elementos de diferentes cuerpos, de manera que haremos buena parte del análisis de estas matrices dentro de Sage.
      </p>
  
      <sage permid="OiJ">
        <input>C = H.parity_check_matrix(); C</input>
        <output>
        [1 0 1 0 1 0 1]
        [0 1 1 0 0 1 1]
        [0 0 0 1 1 1 1]
        </output>
      </sage>
  
      <p permid="jcG">La matriz generadora del texto tienen <em>columnas</em> que son palabras del código, y combinaciones lineales de las columnas (el espacio de columnas de la matriz) son palabras del código.  En Sage la matriz generadora tiene <em>filas</em> que son palabras del código y el espacio de filas de la matriz es el código.  Tenemos acá otro punto en que debemos traducir mentalmente entre una elección hecha en el texto y un elección hecha por los desarrolladores de Sage.
      </p>
  
      <sage permid="upS">
        <input>G = H.generator_matrix(); G</input>
        <output>
        [1 0 0 0 0 1 1]
        [0 1 0 0 1 0 1]
        [0 0 1 0 1 1 0]
        [0 0 0 1 1 1 1]
        </output>
      </sage>
  
      <p permid="PjP">A continuación una verificación parcial de que estas dos matrices son correctas, ejercitando el <xref ref="algcodes-lemma-parity-check"/>.  Note que necesitamos transponer la matriz generadora por las razones expuestas antes.
      </p>
  
      <sage permid="axb">
        <input>C*G.transpose() == zero_matrix(3, 4)</input>
        <output>True</output>
      </sage>
  
      <p permid="vqY">Notemos que la matriz verificadora puede no ser canónica y que la matriz generadora puede no ser estándar.  Sage puede producir una matriz generadora que tenga un conjunto de columnas que formen la matriz identidad, pero no se garantiza que estas columnas sean las primeras.  (Columnas, no filas.)  Tal matriz se dice <term>sistemática</term>, y el método Sage es <c>.systematic_generator_matrix()</c>.
      </p>
  
      <sage permid="GEk">
        <input>H.systematic_generator_matrix()</input>
        <output>
        [1 0 0 0 0 1 1]
        [0 1 0 0 1 0 1]
        [0 0 1 0 1 1 0]
        [0 0 0 1 1 1 1]
        </output>
      </sage>
  
    </subsection>
  
    <subsection permid="gYL">
      <title>Decodificando un Código Lineal</title>
  
      <p permid="byh">Podemos decodificar mensajes recibidos originados por un código lineal.  Supongamos que recibimos el vector binario de largo <m>7</m><c>r</c>.
      </p>
  
      <sage permid="mLt">
        <input>r = vector(GF(2), [1, 1, 1, 1, 0, 0, 1]); r</input>
        <output>(1, 1, 1, 1, 0, 0, 1)</output>
      </sage>
  
      <p permid="HFq">Podemos reconocer que uno o más errores han ocurrido, pues <c>r</c> no pertenece al código, dado que el siguiente cálculo no resulta en el vector cero.
      </p>
  
      <sage permid="SSC">
        <input>C*r</input>
        <output>(1, 1, 0)</output>
      </sage>
  
      <p permid="nMz">Un código lineal tiene un método <c>.decode</c>.  Usted puede elegir entre distintos algoritmos, pero los códigos de Hamming tienen su algoritmo particular.  El algoritmo por defecto es el del uso de síndromes.
      </p>
  
      <sage permid="yZL">
        <input>H.decode_to_code(r)</input>
        <output>(1, 1, 0, 1, 0, 0, 1)</output>
      </sage>
  
      <p permid="TTI">Si estamos dispuesto a suponer que solo ha ocurrido un eror (lo que podemos, si la probabilidad de error en una entrada particular del vector es muy baja), entonces vemos que ocurrió un error en la tercera posición.
      </p>
  
      <p permid="AaR">Recuerde que podría ser que ocurra más de un error.  Por ejemplo, supongamos que el mensaje es el mismo de antes y ocurren errores en la tercera, quinta y sexta posiciones.
      </p>
  
      <sage permid="fgU">
        <input>
        message = vector(GF(2), [1, 1, 0, 1, 0, 0, 1])
        errors = vector(GF(2), [0, 0, 1, 0, 1, 1, 0])
        received = message + errors
        received
        </input>
        <output>(1, 1, 1, 1, 1, 1, 1)</output>
      </sage>
  
      <p permid="gia">Entonces parece querecibimos una palabra del código, por lo que suponemos que no hubo errores en absoluto, y decodificamos incorrectamente.
      </p>
  
      <sage permid="Lod">
        <input>H.decode_to_code(received) == message</input>
        <output>False</output>
      </sage>
  
      <sage permid="rvm">
        <input>H.decode_to_code(received) == received</input>
        <output>True</output>
      </sage>
    </subsection>
  
  </section>
  <exercises xml:id="algcodes-sage-exercises" component="sage-exercises" permid="Zum">
    <title>Ejercicios en Sage</title>
  
    <exercise number="1" permid="UoU" xml:id="algcodes-sage-exercise-golay-code">
      <statement>
        <p permid="ClD">Construya el código (binario) Golay con el constructor <c>codes.GolayCode()</c>.  Lea la documentación para asegurarse de construir la versión binaria (y no la ternaria), y no construya la versión extendida (que es el default).
      </p>
  
        <ol permid="qlt">
          <li permid="DTz"><p permid="CsH">Use métodos Sage para calcular el largo, la dimensión y la distancia mínima del código.
      </p></li>
          <li permid="kaI"><p permid="izQ">¿Cuántos errores puede detectar este código?  ¿Cuántos puede corregir?</p></li>
          <li permid="QhR"><p permid="OGZ">Encuentre una palabra distinta de cero en el código e introduzca tres errores sumando un vector con tres 1's (de su elección) para crear un mensaje recibido.  Muestre que el mensaje se decodifica correctamente.
      </p></li>
          <li permid="wpa"><p permid="uOi">Recicle sus elecciones de la parte anterior, pero ahora agregue un error adicional.  ¿Se decodifica correctamente el mensaje recibido?</p></li>
        </ol>
      </statement>
      
    </exercise>
  
    <exercise number="2" permid="Awd" xml:id="algcodes-sage-exercise-parity-check-bit">
      <statement>
        <p permid="isM">Una técnica que permita mejorar las características de un código es agregar un bit de paridad general, tal como el bit de paridad del código <acro>ASCII</acro> descrito en el <xref ref="algcodes-example-even-parity"/>.  Tales códigos se conocen como versiones <term>extendidas</term> del código original.
      </p>
  
        <ol permid="WsC">
          <li permid="cwj"><p permid="aVr">Construya el código de Golay binario y obtenga la matriz evrificadora.  Use comandos Sage para extender esta matriz creando una nueva matriz de paridad que considere un bit de paridad global adicional.  los métodos <c>.augment()</c> y <c>.stack()</c> para matrices le pueden resultar útiles, así como los constructores <c>zero_vector()</c> y <c>ones_matrix()</c> (recordando que especificamos las entradas binarias como pertenecientes al cuerpo <c>GF(2)</c>.)</p>
  
          <p permid="HcA">Cree el código extendido entregando la matriz de paridad aumentada al constructor <c>codes.from_parity_check_matrix()</c> y calcule la longitud, dimension y distancia mínima del código extendido.
      </p></li>
  
          <li permid="IDs"><p permid="njJ">¿En qué sentido son mejores las características de este nuevo código? ¿A qué costo?</p></li>
  
          <li permid="oKB"><p permid="TqS">Ahora cree el código de Golay binario extendido con <c>codes.GolayCode()</c> y la opción apropiada para obtener la versión extendida.  Con algo de suerte, las listas ordenadas de sus palabras y las del código implementado en Sage, serán las mismas.  Si no, el método <c>.is_permutation_equivalent()</c> debiera retornar <c>True</c> indicando que su código y el de Sage son simplemente reordenamientos, el uno del otro.
      </p></li>
        </ol>
      </statement>
      
    </exercise>
  
    <exercise number="3" permid="gDm" xml:id="algcodes-sage-exercise-buggy-sage-code">
      <statement>
        <p permid="OzV">
          <em>Note:</em> This problem is on holiday
          (as of Sage 6.7),
          while some buggy Sage code for the minimum distance of a Hamming code gets sorted out.
          The <c>r = 2</c> case produces an error message and for <c>r &gt; 5</c> the computation of the minimum distance has become intolerably slow.
          So it is a bit harder to make a reasonable conjecture from just <m>3</m> cases.
        </p>

        <p permid="uHe">El dual de un código de bloque <m>(n,k)</m> está formado por el conjunto de los vectores bianrios ortogonales a todos los vectores del código original.  El <xref ref="algcodes-exercise-dual-code"/> describe esta construcción y pregunta por algunas de sus propiedades.
      </p>
  
        <p permid="aOn">Se puede obtener el dual de un código en Sage con el método <c>.dual_code()</c>.  Construya los códigos de Hamming binarios, y sus duales, con el parámetro <c>r</c> variando desde <c>2</c> hasta <c>5</c>.  Construya una tabla con seis columnas (posiblemente usando la función <c>html.table()</c>) que liste <m>r</m>, el largo del código, la dimensión del código original, la de su dual, la distancia mínima del código y la de su dual.
      </p>
  
        <p permid="GVw">Conjeture fórmulas para la dimensión y distancia mínima del dual de un código de Hamming en términos del parámetro <m>r</m>.
      </p>
      </statement>
      
    </exercise>
  
    <exercise number="4" permid="MKv" xml:id="algcodes-sage-exercise-perfect-code">
      <statement>
        <p permid="ncF">Un código con distancia mínima <m>d</m> se llama <term>perfecto</term> si todo vector posible está a distancia menor o igual a <m>(d-1)/2</m> de alguna palabra del código.  Si expandimos nuestra idea de geometría para incluir la noción de distancia de Hamming como la métrica, entonces podemos hablar de una esfera de radio <m>r</m> en torno a un vector o palabra.  Para un código de longitud <m>n</m>, una esfera de este tipo contiene <me permid="DTM">1 + {n\choose 1} + {n\choose 2} + \cdots + {n\choose r}</me> vectores en su interior.  Para un código perfecto, las esferas de radio <m>(d-1)/2</m> centradas en las palabras del código particionan exactamente el espacio de todos los vectores posibles.  (Esto es lo que establece una relación entre la teoría de códigos y los problemas de empaquetamiento de esferas.)</p>
  
        <p permid="TjO">Una consecuencia de que un código de dimensión <m>k</m> sea perfecto es que <me permid="kaV">2^k\left({n\choose 0} + {n\choose 1} + {n\choose 2} + \cdots + {n\choose \frac{d-1}{2}}\right) = 2^n</me>  Recíprocamente, si un código tiene distancia mínima <m>d</m> y cumple la condición anterior, entonces el código es perfecto.
      </p>
  
        <p permid="zqX">Escriba una función en Sage, llamada <c>is_perfect()</c> que tome un código lineal como entrada y retorne <c>True</c> o <c>False</c> según si el código es o no perfecto.  Demuestre su función verificando que el código de Golay binario es perfecto, y use un bucle para verificar que los códigos de Hamming binarios son perfectos para longitudes menores a <m>32</m>.
      </p>
      </statement>
      
    </exercise>
  
    <!-- Potential exercise 5: probabilty and Shannon bound -->
  </exercises>
  
</chapter>
