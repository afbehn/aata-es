<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 1997-2017  Thomas W. Judson     -->
<!-- See the file COPYING for copying conditions.  -->

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->



<chapter xml:id="finite" xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Cuerpos Finitos</title>

  <introduction>
    <p>Los cuerpos finitos aparecen en muchas aplicaciones del álgebra, incluyendo teoría de códigos y criptografía.  Ya conocemos un cuerpo finito, <m>{\mathbb Z}_p</m>, donde <m>p</m> es primo.  En este capítulo mostraremos que existe un único cuerpo finito de orden <m>p^n</m> para cada primo <m>p</m> y para cada entero positivo <m>n</m>.  Los cuerpos finitos también son llamados cuerpos de Galois en honor a Évariste Galois, quién fue  uno de los primero matemáticos en investigarlos.
    </p>
  </introduction>

  <section xml:id="section-finite-field">
    <title>Estructura de Cuerpos Finitos</title>

    <p>Recuerde que un cuerpo <m>F</m> tiene <term>característica</term> <m>p</m> si <m>p</m> es el menor entero positivo tal que para cada elemento no nulo <m>\alpha</m> en <m>F</m>, tenemos <m>p \alpha = 0</m>.  Si no hay tal entero, entonces <m>F</m> tiene característica 0.  Del <xref ref="theorem-integral-domain-characteristic" /> sabemos que <m>p</m> debe ser primo.  Supongamos que <m>F</m> es un cuerpo finito con <m>n</m> elementos. Entonces <m>n \alpha = 0</m> para todo <m>\alpha</m> en <m>F</m>.  En consecuencia, la característica de <m>F</m> debe ser <m>p</m>, con <m>p</m> un primo que divide a <m>n</m>.  Esta discusión se resume en la siguiente proposición.
    </p>

    <proposition>
      <statement>
        <p>Si <m>F</m> es un cuerpo finito, entonces la característica de <m>F</m> es <m>p</m>, con <m>p</m>  primo.
    </p>
      </statement>
    </proposition>

    <p>En todo este capítulo supondremos que <m>p</m> es un primo a menos que indiquemos lo contrario.
    </p>

    <proposition>
      <statement>
        <p>Si <m>F</m> es un cuerpo finito de característica <m>p</m>, entonces el orden de <m>F</m> es <m>p^n</m> para algún <m>n \in {\mathbb N}</m>.
    </p>
      </statement>
      <proof>
        <p>Sea <m>\phi : {\mathbb Z} \rightarrow F</m> el homomorfismo de anillos definido por <m>\phi(n) = n \cdot 1</m>.  Como la  característica de <m>F</m> es <m>p</m>, el núcleo de <m>\phi</m> debe ser <m>p {\mathbb Z}</m> y la imagen de <m>\phi</m> debe ser un subcuerpo de <m>F</m> isomorfo a <m>{\mathbb Z}_p</m>.  Denotaremos este subcuerpo por <m>K</m>.  Como <m>F</m> es un  cuerpo finito, debe ser una extensión finita de <m>K</m> y, por lo tanto, una extensión algebraica de <m>K</m>. Supongamos que <m>[F : K] = n</m> es la dimensión de <m>F</m>, donde <m>F</m> es un <m>K</m> espacio vectorial.  Deben existir elementos <m>\alpha_1, \ldots, \alpha_n \in F</m> tales que cualquier elemento <m>\alpha</m> en <m>F</m> pueda ser escrito de una única manera en la forma   
          <me>\alpha = a_1 \alpha_1 + \cdots + a_n \alpha_n</me>,
        donde los <m>a_i</m> están en <m>K</m>.  Como hay <m>p</m> elementos en <m>K</m>, hay <m>p^n</m> combincaciones lineales posibles de los <m>\alpha_i</m>.  Por lo tanto, el orden de <m>F</m> debe ser <m>p^n</m>.
    </p>
      </proof>
    </proposition>

    <lemma xml:id="lemma-freshmans-dream">
      <title>El sueño del Pibe</title>
      <idx><h>El sueño del Pibe</h></idx>
      <statement>
        <p>Sea <m>p</m> un primo y sea <m>D</m> un dominio integral de característica <m>p</m>.  Entonces
          <me>a^{p^n} + b^{p^n} = (a + b)^{p^n}</me>
        para todo entero positivo <m>n</m>.
    </p>
      </statement>
      <proof>
        <p>Procederemos por inducción en <m>n</m>.  Podemos usar la fórmula del binomio (vea el Capí<xref ref="integers" />, <xref ref="example-integers-binomial-theorem" />) para verificar el caso <m>n = 1</m>; es decir,
          <me>(a + b)^p = \sum_{k = 0}^{p} \binom{p}{k} a^k b^{p - k}</me>.
        Si <m>0 \lt k \lt p</m>, entonces
          <me>\binom{p}{k} = \frac{p!}{k!(p - k)!}</me>
        debe ser divisible por <m>p</m>, pues <m>p</m> no puede dividir a <m>k!(p - k)!</m>.  Note que <m>D</m> es un dominio integral de característica <m>p</m>, así es que todos los términos de la suma, salvo el primero y el último son cero.  Por lo tanto, <m>(a + b)^p = a^p + b^p</m>.
    </p>  

        <p>Ahora supongamos que el resultado se cumple para todo <m>k</m>, con <m>1 \leq k \leq n</m>.  Por la hipótesis de inducción,
          <me>(a + b)^{p^{n + 1}} = ((a + b)^p)^{p^{n}} = (a^p + b^p)^{p^{n}} = (a^p)^{p^{n}} + (b^p)^{p^{n}} = a^{p^{n + 1}} + b^{p^{n + 1}}</me>.
        Por lo tanto, el lema es verdadero para <m>n + 1</m> y la demostración está completa.
    </p>
      </proof>
    </lemma>

    <p>Sea <m>F</m> un cuerpo.  Un polinomio <m>f(x) \in F[x]</m> de grado <m>n</m> es <term>separable</term><idx><h>Polynomio separable</h></idx> si tiene <m>n</m> raíces distintas en el cuerpo de descomposición de <m>f(x)</m>; es decir, <m>f(x)</m> es separable cuando se factoriza en factores lineales distintos sobre el cuerpo de descomposición de <m>f</m>.  Una extensión <m>E</m> de <m>F</m> es una <term>extensión separable</term><idx><h>Separable</h><h>extensión</h></idx> de <m>F</m> si todo elemento en <m>E</m> es la raíz de un polinomio separable en <m>F[x]</m>.
    </p>

<!-- Corrected typo.  Suggested by C. Wall. - TWJ 5/15/2012 -->

    <example>
      <p>El polinomio <m>x^2 - 2</m> es separable sobre <m>{\mathbb Q}</m> pues se factoriza como <m>(x - \sqrt{2}\, )(x + \sqrt{2}\, )</m>. De hecho, <m>{\mathbb Q}(\sqrt{2}\, )</m> es una extensión separable de <m>{\mathbb Q}</m>.  Sea <m>\alpha =  a + b \sqrt{2}</m> un elemento cualquiera en <m>{\mathbb Q}(\sqrt{2}\, )</m>. Si <m>b = 0</m>, entonces <m>\alpha</m> es una raíz de <m>x - a</m>.  Si <m>b \neq 0</m>, entonces <m>\alpha</m> es la raíz del polinomio separable  
        <me>x^2 - 2 a x + a^2 - 2 b^2 = (x - (a + b \sqrt{2}\, ))(x - (a - b \sqrt{2}\, ))</me>.
    </p>
    </example>

<!-- Notation error corrected.  Suggested by C. Wall.  TWJ 5/15/2012 -->
 
    <p>Afortunadamente, tenemos una forma fácil para determinar la separabilidad de cualquier polinomio.  Sea
      <me>f(x) = a_0 + a_1 x + \cdots + a_n x^n</me>
    un polinomio en  <m>F[x]</m>. Se define la <term>derivada</term><idx><h>Derivada</h></idx> de <m>f(x)</m> como 
      <me>f'(x) = a_1  + 2 a_2 x + \cdots + n a_n x^{n - 1}</me>.
    </p>

    <lemma xml:id="lemma-separable-derivative">
      <statement>
        <p>Sea <m>F</m> un cuerpo y <m>f(x) \in F[x]</m>.  Entonces <m>f(x)</m> es separable si y solo si <m>f(x)</m> y <m>f'(x)</m> son relativamente primos.
    </p>
      </statement>
      <proof>
        <p>Sea <m>f(x)</m> separable.  Entonces <m>f(x)</m> se factoriza sobre algún cuerpo de extensión de <m>F</m> como <m>f(x) = (x - \alpha_1) (x - \alpha_2) \cdots (x - \alpha_n)</m>, con <m>\alpha_i \neq \alpha_j</m> para <m>i \neq j</m>. Tomando la derivada de <m>f(x)</m>, vemos que
          <md>
            <mrow>f'(x) &amp; =  (x - \alpha_2) \cdots (x - \alpha_n)</mrow>
            <mrow>&amp;  +  (x - \alpha_1) (x - \alpha_3) \cdots (x - \alpha_n)</mrow>
            <mrow>&amp;  + \cdots + (x - \alpha_1) \cdots (x - \alpha_{n - 1})</mrow>
          </md>.
        Luego, <m>f(x)</m> y <m>f'(x)</m> no pueden tener ningún factor común.
    </p>

        <p>Para demostrar el recíproco, mostraremos que se cumple la afirmación contrapositiva.  Supongamos que <m>f(x) = (x - \alpha)^k g(x)</m>, con <m>k \gt 1</m>.  Derivando, tenemos
          <me>f'(x) = k ( x - \alpha)^{k-1} g(x) + (x- \alpha)^k g'(x)</me>.
        Por lo tanto, <m>f(x)</m> y <m>f'(x)</m> tienen un factor común.
    </p>
      </proof>
    </lemma>

    <theorem xml:id="theorem-finite-splitting-field">
      <statement>
        <p>Para cada primo <m>p</m> y para cada entero positivo <m>n</m>, existe un cuerpo finito <m>F</m> con <m>p^n</m> elementos. Más aún, cualquier cuerpo de orden <m>p^n</m> es isomorfo al cuerpo de descomposición de <m>x^{p^n} -x</m> sobre  <m>{\mathbb Z}_p</m>.
    </p>
      </statement>
<!-- % TWJ 11/20/2011 -->
<!-- % Reference to Lemma 22.4 corrected in proof.  Suggested by A. Johnston. -->

      <proof>
        <p>Sea <m>f(x) = x^{p^n} - x</m> y sea <m>F</m> el cuerpo de descomposición de <m>f(x)</m>.  Por el <xref ref="lemma-separable-derivative" />, <m>f(x)</m> tiene <m>p^n</m> ceros distintos en <m>F</m>, pues <m>f'(x) = p^n x^{p^n - 1} - 1 = -1</m> es relativamente primo con <m>f(x)</m>.  Afirmamos que las raíces de <m>f(x)</m> forman un subcuerpo de <m>F</m>.  Ciertamente 0 y 1 son ceros de <m>f(x)</m>.  Si <m>\alpha</m> y <m>\beta</m> son ceros de <m>f(x)</m>, entonces <m>\alpha + \beta</m> y <m>\alpha \beta</m> también son ceros de <m>f(x)</m>, pues <m>\alpha^{p^n} + \beta^{p^n} =  (\alpha + \beta)^{p^n}</m> y <m>\alpha^{p^n} \beta^{p^n} = (\alpha \beta)^{p^n}</m>. También debemos mostrar que el inverso aditivo y el inverso multiplicativo de cada raíz de <m>f(x)</m> son raíces de <m>f(x)</m>.  Para cualquier cero <m>\alpha</m> de <m>f(x)</m>, sabemos que <m>-\alpha</m> también es cero de <m>f(x)</m>, pues
          <me>f(-\alpha) = (-\alpha)^{p^n} - (-\alpha) = -\alpha^{p^n} + \alpha = -(\alpha^{p^n} - \alpha) = 0</me>,
        suponiendo que <m>p</m> is impar.  Si <m>p = 2</m>, entonces 
          <me>f(-\alpha) =  (-\alpha)^{2^n} - (-\alpha) = \alpha + \alpha = 0</me>.
        Si <m>\alpha \neq 0</m>, entonces <m>(\alpha^{-1})^{p^n} = (\alpha^{p^n})^{-1} = \alpha^{-1}</m>. Como los ceros de <m>f(x)</m> forman un subcuerpo de <m>F</m> y <m>f(x)</m> se descompone en este subcuerpo, el subcuerpo debe ser todo <m>F</m>.
    </p>

        <p>Sea <m>E</m> cualquier otro cuerpo de orden <m>p^n</m>.  Para mostrar que <m>E</m> es isomorfo a <m>F</m>, debemos mostrar que todo elemento en <m>E</m> es una raíz de <m>f(x)</m>.  Claramente 0 y 1 son raíces de <m>f(x)</m>.  Sea <m>\alpha</m> un elemento no nulo de <m>E</m>.  El orden del grupo multiplicativo de elementos no nulos de <m>E</m> es <m>p^n-1</m>; luego, <m>\alpha^{p^n-1} =1</m> y <m>\alpha^{p^n} -\alpha = 0</m>.  Como <m>E</m> contiene <m>p^n</m> elementos, <m>E</m> debe ser un cuerpo de descomposición de <m>f(x)</m>; pero, por el <xref ref="corollary-poly-splitting-field" />, el cuerpo de descomposición de cualquier polinomio es único salvo isomorfía.
    </p>
      </proof>
    </theorem>

    <p>El único cuerpo con <m>p^n</m> elementos se llama <term>cuerpo de Galois </term><idx><h>Cuerpo de Galois</h></idx><idx><h>Galois</h><h>cuerpo de</h></idx> de orden <m>p^n</m>. Denotaremos este cuerpo por <m>\gf(p^n)</m>. <notation><usage><m>\gf(p^n)</m></usage><description>Cuerpo de Galois de orden <m>p^n</m></description></notation></p>

    <theorem xml:id="theorem-finite-subfields">
      <statement>
        <p>Todo subcuerpo del cuerpo de Galois <m>\gf(p^n)</m> tiene <m>p^m</m> elementos, con <m>m</m> un divisor de <m>n</m>.  Recíprocamente, si <m>m \mid n</m> para <m>m \gt 0</m>, entonces  existe un único subcuerpo de <m>\gf(p^n)</m> isomorfo a <m>\gf(p^m)</m>.
    </p>
      </statement>
      <proof>
        <p>Sea <m>F</m> un subcuerpo de <m>E = \gf(p^n)</m>.  Entonces <m>F</m> debe ser una extensión de <m>K</m> que contiene  <m>p^m</m> elementos, donde <m>K</m> es isomorfo a <m>{\mathbb Z}_p</m>.   Entonces <m>m \mid n</m>, pues <m>[E:K] = [E:F][F:K]</m>.
    </p>

        <p>Para demostrar el recíproco, supongamos que <m>m \mid n</m> para algún <m>m \gt 0</m>.  Entonces <m>p^m -1</m> divide a <m>p^n -1</m>. En consecuencia, <m>x^{p^m -1} - 1</m> divide a <m>x^{p^n -1} -1</m>. Por lo tanto, <m>x^{p^m} - x</m> debe dividir a <m>x^{p^n} - x</m>, y todo cero de <m>x^{p^m} - x</m> también es un cero de <m>x^{p^n} - x</m>. Luego, <m>\gf(p^n)</m> contiene, como subcuerpo, un cuerpo de descomposición de <m>x^{p^m} - x</m>, que debe ser isomorfo a <m>\gf(p^m)</m>.
    </p>
      </proof>
    </theorem>

<!--  2010/05/18 R Beezer, added space before Figure citation -->
    <example xml:id="example-finite-gf-p24">
      <p>El reticulado de subcuerpos de <m>\gf(p^{24})</m> está dado en la <xref ref="figure-field-lattice" />.
    </p>
    </example>

    <figure xml:id="figure-field-lattice">
      <caption>Subcuerpos de <m>\gf(p^{24})</m></caption>

      <!-- Replaced figure with tikz figure - TWJ 8/20/2010 -->
      <image width="50%" xml:id="finite-subfield-lattice" permid="YFo">
		<description>Una red de inclusiones de cuerpo con el nivel superior un cuerpo de Galois de p^24 elementos. El segundo nivel tiene cuerpos Galois de elementos p^8 y p^12 que se incluyen en el nivel superior. El tercer nivel tiene cuerpos Galois de p^4 (incluidos en los cuerpos de p^8 y p^12 elementos) y p^6 elementos (incluidos en el cuerpo de p^12 elementos). El cuarto nivel tiene cuerpos Galois de p^2 (incluidos en los cuerpos de p^4 y p^16 elementos) y p^3 elementos (incluidos en el cuerpo de p^6 elementos). El nivel inferior es un cuerpo Galois de p elementos (incluido en los cuerpos de p^2 y p^3 elementos).</description>
	  <latex-image>
		  <xi:include href="tikz/finite-subfield-lattice.tex" parse="text"/>
	  </latex-image>
</image>
    </figure>

    <p>Con cada cuerpo <m>F</m> tenemos un grupo multiplicativo de elementos no nulos de <m>F</m> que denotaremos por <m>F^*</m>. <notation><usage><m>F^*</m></usage><description>grupo multiplicativo de un cuerpo <m>F</m></description></notation> El grupo multiplicativo de un cuerpo finito cualquiera es cíclico.  Este resultado se sigue del resultado más general que demostraremos en el próximo teorema.
    </p> 

    <theorem xml:id="theorem-mult-group-finite-field">
      <statement>
        <p>Si <m>G</m> es un subgrupo finito de <m>F^\ast</m>, el grupo multiplicativo de elementos no nulos de un cuerpo <m>F</m>, entonces <m>G</m> es cíclico.
    </p>
      </statement>
      <proof>
        <p>Sea <m>G</m> un subgrupo finito de <m>F^\ast</m> de orden <m>n</m>.  Por el Teorema Fundamental de Grupos Abelianos (<xref ref="theorem-finite-abelian-groups" />),  
          <me>G \cong {\mathbb Z}_{p_1^{e_1}} \times \cdots \times {\mathbb Z}_{p_k^{e_k}}</me>,
        donde <m>n = p_1^{e_1} \cdots p_k^{e_k}</m> y los  <m>p_1, \ldots, p_k</m> son primos (no necesariamente distintos). Sea <m>m</m> el mínimo común múltiplo de <m>p_1^{e_1}, \ldots, p_k^{e_k}</m>.  Entonces <m>G</m> contiene un elemento de orden <m>m</m>.  Como todo <m>\alpha</m> en <m>G</m> satisface <m>x^r - 1</m> para algún <m>r</m> que divide a <m>m</m>, <m>\alpha</m> debe también ser raíz de <m>x^m - 1</m>.  Como <m>x^m -1</m> tiene a lo más <m>m</m> raíces en <m>F</m>, <m>n \leq m</m>.  Por otra parte, sabemos que <m>m \leq |G|</m>; por lo tanto, <m>m = n</m>. Luego, <m>G</m> contiene un elemento de orden <m>n</m> y tiene que ser cíclico.
    </p>
      </proof>
    </theorem>

<!-- Rewrote the first part of the proof.  Suggested by R. Beezer. -->
<!-- TWJ - 24/4/2013 -->

    <corollary xml:id="corollary-cyclic-group-finite-field">
      <statement>
        <p>El grupo multiplicativo de todos los elementos no nulos de un cuerpo finito es cíclico.
    </p>
      </statement>
    </corollary>

    <corollary xml:id="corollary-finite-extension-finite-field">
      <statement>
        <p>Toda extensión finita <m>E</m> de un cuerpo finito <m>F</m> es una extensión simple de <m>F</m>.
    </p>
      </statement>
      <proof>
        <p>Sea <m>\alpha</m> un generador del grupo cíclico <m>E^{\ast}</m> de elementos distintos de cero de <m>E</m>. Entonces <m>E = F( \alpha )</m>.
    </p>
      </proof>
    </corollary>

    <example xml:id="example-finite-gf-2-4">
      <p>El cuerpo finito <m>\gf(2^4)</m> es isomorfo al cuerpo <m>{\mathbb Z}_2/ \langle 1 + x + x^4 \rangle</m>. Por lo tanto, los elementos de <m>\gf(2^4)</m> se puede tomar como
        <me>\{ a_0 + a_1 \alpha + a_2 \alpha^2 + a_3 \alpha^3 : a_i \in {\mathbb Z}_2 \text{ y } 1 + \alpha + \alpha^4 = 0 \}</me>.
      Recordando que <m>1 + \alpha +\alpha^4 = 0</m>, sumamos y multiplicamos elementos de  <m>\gf(2^4)</m> exactamente como sumamos y multiplicamos polinomios.  El grupo multiplicativo de <m>\gf(2^4)</m> es isomorfo a <m>{\mathbb  Z}_{15}</m> con generador <m>\alpha</m>: 
        <md>
          <mrow>&amp; \alpha^1 = \alpha &amp; &amp; \alpha^6 = \alpha^2 + \alpha^3 &amp; &amp; \alpha^{11} = \alpha + \alpha^2 + \alpha^3 &amp;</mrow>
          <mrow>&amp; \alpha^2 = \alpha^2 &amp; &amp; \alpha^7 = 1 + \alpha + \alpha^3 &amp; &amp; \alpha^{12} = 1 + \alpha + \alpha^2 + \alpha^3 &amp;</mrow>
          <mrow>&amp; \alpha^3 = \alpha^3 &amp; &amp; \alpha^8 = 1 + \alpha^2 &amp; &amp; \alpha^{13} = 1 + \alpha^2 + \alpha^3 &amp;</mrow>
          <mrow>&amp; \alpha^4 = 1 + \alpha &amp; &amp; \alpha^9 = \alpha + \alpha^3 &amp; &amp; \alpha^{14} = 1 + \alpha^3 &amp;</mrow>
          <mrow>&amp;\alpha^5 = \alpha + \alpha^2 &amp; &amp; \alpha^{10} = 1 + \alpha + \alpha^2 &amp; &amp; \alpha^{15} = 1. &amp;</mrow>
        </md></p>
    </example>

  </section>

  <section xml:id="section-poly-codes">
    <title>Códigos Polinomiales</title>

<!-- TWJ 2012/11/21 -->
<!-- Chapter reference updated.  Suggested by J. Buller. -->

    <introduction>

      <p>Sabiendo sobre anillos de polinomios y cuerpos finitos, es posible derivar códigos más sofisticados que los del Capí<xref ref="algcodes" />.  En primer lugar recordemos que un código de bloques <m>(n, k)</m> consiste de una función codificadora inyectiva <m>E:{\mathbb Z}^{k}_{2} \rightarrow {\mathbb Z}^{n}_{2}</m> y una función decodificadora <m>D:{\mathbb Z}^{n}_{2} \rightarrow {\mathbb Z}^{k}_{2}</m>.  El código es corrector de errores si <m>D</m> es sobreyectivo.  Un código es lineal si es el espacio nulo de una matriz <m>H \in {\mathbb M}_{k \times n}({\mathbb Z}_2)</m>. </p>

      <p>Estamos interesados en una clase de códigos conocidos como códigos cíclicos<idx><h>Código</h><h>cíclico</h></idx>.  Sea <m>\phi : {\mathbb Z}_2^k \rightarrow {\mathbb  Z}_2^n</m> un código de bloques <m>(n,k)</m> binario.  Entonces <m>\phi</m> es un <term>código cíclico</term> si para cada palabra <m>(a_1, a_2, \ldots, a_n )</m> en el código, la palabra formada por desplazamiento cíclico, la <m>n</m>-tupla <m>(a_n, a_1, a_2, \ldots, a_{n - 1} )</m> también está en el código.  Los códigos cíclicos son fáciles de implementar en un computador usando registro de shift [2, 3].
    </p>

      <example xml:id="example-finite-6-3-linear-code">
        <p>Considere los código lineales <m>(6,3)</m>generados por las dos matrices
          <me>G_1 
          = 
          \begin{pmatrix}<![CDATA[
          1 & 0 & 0 \\
          0 & 1 & 0 \\
          0 & 0 & 1 \\
          1 & 0 & 0 \\
          0 & 1 & 0 \\
          0 & 0 & 1 
          ]]>\end{pmatrix}
          \quad
          \text{y}
          \quad
          G_2 = 
          \begin{pmatrix}<![CDATA[
          1 & 0 & 0 \\
          1 & 1 & 0 \\
          1 & 1 & 1 \\
          1 & 1 & 1 \\
          0 & 1 & 1 \\
          0 & 0 & 1
          ]]>\end{pmatrix}</me>.
        Los mensajes del primero se codifican como sigue:
          <me>\begin{array}{rclccrcl}
          (000) &amp; \mapsto &amp; (000000) &amp; &amp; &amp; (100) &amp; \mapsto &amp; (100100) \\
          (001) &amp; \mapsto &amp; (001001) &amp; &amp; &amp; (101) &amp; \mapsto &amp; (101101) \\
          (010) &amp; \mapsto &amp; (010010) &amp; &amp; &amp; (110) &amp; \mapsto &amp; (110110) \\
          (011) &amp; \mapsto &amp; (011011) &amp; &amp; &amp; (111) &amp; \mapsto &amp; (111111).
          \end{array}</me>
        Es fácil ver que las palabras del código forman un código cíclico.  En el segundo, las 3-tuplas se codifican de la siguiente manera:
          <me>\begin{array}{rclccrcl}
          (000) &amp; \mapsto &amp; (000000) &amp; &amp; &amp; (100) &amp; \mapsto &amp; (111100) \\
          (001) &amp; \mapsto &amp; (001111) &amp; &amp; &amp; (101) &amp; \mapsto &amp; (110011) \\
          (010) &amp; \mapsto &amp; (011110) &amp; &amp; &amp; (110) &amp; \mapsto &amp; (100010) \\
          (011) &amp; \mapsto &amp; (010001) &amp; &amp; &amp; (111) &amp; \mapsto &amp; (101101).
          \end{array}</me>
        Este código no es cíclico, pues <m>(101101)</m> es una palabra del código pero  <m>(011011)</m> no lo es.
    </p>
      </example>

    </introduction>

    <subsection xml:id="finite-subsection-poly-codes">
      <title>Códigos Polinomiales</title>

      <p>Nos gustaría encontrar un método fácil para obtener códigos cíclicos lineales.  Para lograr esto, podemos usar lo que sabemos de cuerpos finitos y anillos de polinomios sobre <m>{\mathbb Z}_2</m>.  Cualquier <m>n</m>-tupla binaria se puede interpretar como un polinomio en <m>{\mathbb Z}_2[x]</m>.  Dicho de otra forma, la  <m>n</m>-tupla <m>(a_0, a_1, \ldots, a_{n - 1} )</m> corresponde al polinomio
        <me>f(x) = a_0 +  a_1 x +  \cdots + a_{n-1} x^{n - 1}</me>,
      donde el grado de  <m>f(x)</m> es a lo más <m>n - 1</m>.   Por ejemplo, el polinomio correspondiente a la 5-tupla <m>(10011)</m> es
        <me>1 + 0 x + 0 x^2 + 1 x^3 + 1 x^4 = 1 + x^3 + x^4</me>.
      Recíprocamente, dado cualquier polinomio <m>f(x) \in {\mathbb Z}_2[x]</m> con <m>\deg f(x) \lt n</m> le podemos asociar una <m>n</m>-tupla binaria. El polinomio <m>x + x^2 + x^4</m> corresponde a la 5-tupla <m>(01101)</m>.
    </p>

      <p>Fijemos un polinomio no constante <m>g(x)</m> en <m>{\mathbb Z}_2[x]</m> de grado <m>n - k</m>. Podemos definir un <m>(n,k)</m>-código <m>C</m> de la siguiente manera.  Si <m>(a_0, \ldots, a_{k - 1})</m> es una <m>k</m>-tupla a codificar, entonces <m>f(x) = a_0 + a_1 x +  \cdots + a_{k - 1} x^{k - 1}</m> es el correspondiente polinomio en <m>{\mathbb Z}_2[x]</m>.  Para codificar <m>f(x)</m>, lo multiplicamos por <m>g(x)</m>.  Las palabras en <m>C</m> son todos aquellos polinomios en <m>{\mathbb Z}_2[x]</m> de grado menor a <m>n</m> que son divisibles por <m>g(x)</m>.  Los Códigos obtenidos de esta manera se llaman <term>códigos polinomiales</term><idx><h>Código</h><h>polinomial</h></idx><idx><h>Polinomial</h><h>código</h></idx>.
    </p> 


      <example xml:id="example-finite-generator-63-code">
<!-- Changed minimal polynomial from  (1 + x^3)x^3 &amp; = x^2 + x^5 to (1 + x^3)x^2 &amp; = x^2 + x^5.  Discovered by Jon Buller - TWJ 3/25/2011 -->
        <p>Si <m>g(x)= 1 + x^3</m>, podemos definir un <m>(6,3)</m>-código <m>C</m> como sigue.  Para codificar una 3-tupla <m>( a_0, a_1, a_2 )</m>, multiplicamos el correspondiente polinomio <m>f(x) = a_0 + a_1 x + a_2 x^2</m> por <m>1 + x^3</m>.  Estamos definiendo una función <m>\phi : {\mathbb Z}_2^3 \rightarrow {\mathbb Z}_2^6</m> como <m>\phi  : f(x) \mapsto g(x) f(x)</m>.  Es fácil verificar que esta función es un homomorfismo de grupos.  De hecho, si consideramos <m>{\mathbb Z}_2^n</m> como un espacio vectorial sobre <m>{\mathbb Z}_2</m>, <m>\phi</m> es una transformación lineal de espacios vectoriales (vea el <xref ref="exercise-vect-linear-transformation" />, Capí<xref ref="vect" />).  Calculemos el núcleo de <m>\phi</m>.  Observe que <m>\phi ( a_0, a_1, a_2 ) = (000000)</m> exactamente cuando 
          <md>
            <mrow>0 + 0x + 0x^2 + 0x^3 + 0x^4 + 0 x^5 &amp; = (1 + x^3) ( a_0 + a_1 x + a_2 x^2 )</mrow>
            <mrow> &amp; = a_0 + a_1 x + a_2 x^2 + a_0 x^3 + a_1 x^4 + a_2 x^5</mrow>
          </md>.
        Como los polinomios sobre un cuerpo forman un dominio integral, <m>a_0 + a_1 x + a_2 x^2</m> debe ser el polinomio cero. Por lo tanto, <m>\ker \phi = \{ (000) \}</m> y <m>\phi</m> es 1-1.
    </p>
 
        <p>Para calcular una matriz generadora para <m>C</m>, solo debemos examinar cómo se codifican los polinomios <m>1</m>, <m>x</m>, y <m>x^2</m>:
          <md>
            <mrow>(1 + x^3) \cdot 1 &amp; = 1 + x^3</mrow>
            <mrow>(1 + x^3)x &amp; = x + x^4</mrow>
            <mrow>(1 + x^3)x^2 &amp; = x^2 + x^5. </mrow>
          </md>
        Obtenemos el código correspondiente a la matriz generadora <m>G_1</m> en el <xref ref="example-finite-6-3-linear-code" />.  la matriz de verificación de paridad para este código es
          <me>H
          = 
          \begin{pmatrix}<![CDATA[
          1 & 0 & 0 & 1 & 0 & 0 \\
          0 & 1 & 0 & 0 & 1 & 0 \\
          0 & 0 & 1 & 0 & 0 & 1 
          ]]>\end{pmatrix}</me>.
        Como el menor peso de cualquier palabra no nula del código es 2, este código es capaz de detectar cualquier error único.
    </p>
      </example>

      <p>Los anillos de Polinomios tienen una estructura muy rica; por lo tanto, nuestro objetivo inmediato es establecer una relación entre los códigos polinomiales y la teoría de anillos. Recuerde que <m>x^n - 1 = (x - 1)( x^{n-1} + \cdots + x + 1)</m>.  El anillo cociente
        <me>R_n = {\mathbb Z}_2[x]/ \langle x^n - 1 \rangle</me>
      puede ser considerado como el anillo de polinomios de la forma 
        <me>f(t) = a_0 + a_1 t + \cdots + a_{n-1} t^{n-1}</me>
      que satisfacen la condición <m>t^n = 1</m>.  Es un ejercicio sencillo mostrar que <m>{\mathbb Z}_2^n</m> y <m>R_n</m> son isomorfos como espacios vectoriales.  Frecuentemente interpretaremos los elementos en <m>{\mathbb Z}_2^n</m> con elementos en <m>{\mathbb Z_2}[x] / \langle x^n - 1 \rangle</m>.  De esta forma podemos interpretar un código lineal como un subconjunto de <m>{\mathbb Z_2}[x] / \langle x^n - 1 \rangle</m>.
    </p>

      <p>La estructura adicional de anillo en los códigos polinomiales es muy poderosa para describir códigos cíclicos. Un shift cíclico de una <m>n</m>-tupla puede ser descrito por una multiplicación polinomial.  Si <m>f(t) = a_0 + a_1 t + \cdots + a_{n-1} t^{n-1}</m> es un código polinomial en <m>R_n</m>, entonces
        <me>tf(t) = a_{n-1} + a_0 t + \cdots + a_{n-2} t^{n-1}</me>
      es la palabra desplazada cíclicamente obtenida de multiplicar <m>f(t)</m> por <m>t</m>.  El siguiente teorema entrega una hermosa clasificación de los códigos cíclicos en términos de los ideales de <m>R_n</m>.
    </p>

      <theorem xml:id="theorem-cyclic-code">
        <statement>
          <p>Un código lineal <m>C</m> en <m>{\mathbb Z}_2^n</m> es cíclico si y solo si es un ideal en <m>R_n = {\mathbb Z_2}[x] / \langle x^n - 1 \rangle</m>.
    </p>
        </statement>
        <proof>
          <p>Sea <m>C</m> un código cíclico lineal y supongamos que <m>f(t)</m> está en <m>C</m>.  Entonces <m>t f(t)</m> también está en <m>C</m>. Así, <m>t^k f(t)</m> está en  <m>C</m> para todo <m>k \in {\mathbb N}</m>.  Como <m>C</m> es un código lineal, cualquier combinación lineal de las palabras <m>f(t), tf(t), t^2f(t), \ldots, t^{n-1}f(t)</m> también es una palabra del código; por lo tanto, para cada polinomio <m>p(t)</m>, <m>p(t)f(t)</m> está en <m>C</m>.  Luego, <m>C</m> es un ideal.
    </p>

          <p>Recíprocamente, sea <m>C</m> un ideal en  <m>{\mathbb Z}_2[x]/\langle x^n + 1\rangle</m>. Supongamos que <m>f(t) = a_0 + a_1 t + \cdots + a_{n - 1} t^{n - 1}</m> es una palabra en <m>C</m>.  Entonces <m>t f(t)</m> es una palabra en <m>C</m>; es decir, <m>(a_1, \ldots, a_{n-1}, a_0)</m> está en <m>C</m>.
    </p>
        </proof>
      </theorem>
 
      <!--Todo Revisar esta demostración-->

      <p>El <xref ref="theorem-cyclic-code" /> nos dice que conocer los ideales de <m>R_n</m> es equivalente a conocer los códigos cíclicos en <m>{\mathbb Z}_2^n</m>.  Afortunadamente es fácil describir los ideales en <m>R_n</m>.  El homomorfismo natural <m>\phi : {\mathbb Z}_2[x] \rightarrow R_n</m> definido por <m>\phi[f(x)] = f(t)</m> es un homomorfismo epiyectivo.  El núcleo de <m>\phi</m> es el ideal generado por <m>x^n - 1</m>.  Por el <xref ref="theorem-correspondence-rings" />, todo ideal <m>C</m> en <m>R_n</m> es de la forma <m>\phi(I)</m>, donde <m>I</m> es un ideal en <m>{\mathbb Z}_2[x]</m> que contiene al ideal <m>\langle x^n - 1 \rangle</m>.  Por el <xref ref="theorem-poly-principal-ideal" />, sabemos que todo ideal en <m>{\mathbb Z}_2[x]</m> es un ideal principal, pues <m>{\mathbb Z}_2</m> es un cuerpo. Por lo tanto, <m>I = \langle g(x) \rangle</m> para algún polinomio mónico en <m>{\mathbb Z}_2[x]</m>. Como <m>\langle x^n - 1 \rangle</m> está contenido en <m>I</m>, se debe tener que <m>g(x)</m> divide a <m>x^n - 1</m>. Así, todo ideal <m>C</m> en <m>R_n</m> es de la forma 
        <me>C = \langle g(t) \rangle = \{ f(t)g(t) : f(t) \in R_n \text{ y } g(x) \mid (x^n - 1) \text{ en } {\mathbb Z}_2[x] \}</me>.
      El polinomio único de grado mínimo que genera <m>C</m> se llama <term>polinomio generador minimal</term><idx><h>Polinomio generador minimal</h></idx><idx><h>Generador minimal</h><h>polinomio</h></idx> de <m>C</m>.
    </p>


      <example xml:id="example-finite-factor-x7-1">
        <p>Si factorizamos <m>x^7 - 1</m> en sus componentes irreducibles, tenemos
          <me>x^7 - 1 = (1 + x)(1 + x + x^3)(1+ x^2 + x^3)</me>.
        Vemos que <m>g(t) = (1 + t + t^3)</m> genera un ideal <m>C</m> en <m>R_7</m>.  Este es un código de bloque <m>(7, 4)</m>.  Como en el <xref ref="example-finite-generator-63-code" />, es fácil calcular una matriz generadora examinando qué le hace <m>g(t)</m> a los polinomios 1, <m>t</m>, <m>t^2</m>, y <m>t^3</m>.  Una matriz generadora para <m>C</m> es 
          <me>G =
          \begin{pmatrix}<![CDATA[
          1 & 0 & 0 & 0 \\
          1 & 1 & 0 & 0 \\
          0 & 1 & 1 & 0 \\
          1 & 0 & 1 & 1 \\
          0 & 1 & 0 & 1 \\
          0 & 0 & 1 & 0 \\
          0 & 0 & 0 & 1
          ]]>\end{pmatrix}</me>.
    </p>
      </example>
 
      <p>En general, podemos determinar una matriz generadora para un código <m>(n, k)</m> <m>C</m> por la forma en que se codifican los elementos <m>t^k</m>. Sea <m>x^n - 1 = g(x) h(x)</m> en <m>{\mathbb Z}_2[x]</m>. Si <m>g(x) = g_0 + g_1 x + \cdots + g_{n-k} x^{n-k}</m> y <m>h(x) = h_0 + h_1 x +  \cdots + h_k x^k</m>, entonces la matriz de <m>n \times k</m>
        <me>G = 
        \begin{pmatrix}<![CDATA[
        g_0 & 0   & \cdots & 0 \\
        g_1 & g_0 & \cdots & 0 \\
        \vdots & \vdots &\ddots & \vdots \\
        g_{n-k}   & g_{n-k-1} & \cdots & g_0 \\
        0   & g_{n-k} & \cdots & g_{1} \\
        \vdots & \vdots & \ddots & \vdots \\
        0   & 0 & \cdots & g_{n-k}
        ]]>\end{pmatrix}</me>
      es una matriz generadora para el código <m>C</m> con generador polinomial <m>g(t)</m>.  La matriz de verificación de paridad para <m>C</m> es la matriz de <m>(n-k) \times n</m> 
        <me>H =
        \begin{pmatrix}<![CDATA[
        0   & \cdots & 0   & 0      & h_k    & \cdots & h_0 \\
        0   & \cdots & 0 & h_k & \cdots & h_0    & 0 \\
        \cdots  & \cdots & \cdots  & \cdots &  \cdots &  \cdots & \cdots \\
        h_k & \cdots & h_0 & 0      & 0      & \cdots & 0 
        ]]>\end{pmatrix}</me>.
      Dejaremos los detalles de la demostreción de la siguiente proposición como un ejercicio.
    </p>

      <proposition>
        <statement>
          <p>Sea <m>C = \langle g(t) \rangle</m> un código cíclico en <m>R_n</m> y supongamos que <m>x^n - 1 = g(x) h(x)</m>.  Entonces <m>G</m> y <m>H</m> son matriz generadora y verificadora para <m>C</m>, respectivamente.  Más aún, <m>HG = 0</m>.
    </p>
        </statement>
      </proposition>

      <example xml:id="example-finite-parity-check-x7-1">
        <p>En el <xref ref="example-finite-factor-x7-1" />,
          <me>x^7 - 1 = g(x) h(x) = (1 + x + x^3)(1 + x + x^2 + x^4)</me>.
        Por lo tanto, una matriz verificadora para este código es
          <me>H =
          \begin{pmatrix}<![CDATA[
          0 & 0 & 1 & 0 & 1 & 1 & 1 \\
          0 & 1 & 0 & 1 & 1 & 1 & 0 \\
          1 & 0 & 1 & 1 & 1 & 0 & 0
          ]]>\end{pmatrix}</me>.
    </p>
      </example>

      <p>Para determinanr las capacidades de detección y corrección de errores de un código cíclico, necesitamos saber algo sobre determinantes.  Si <m>\alpha_1, \ldots, \alpha_n</m> son elementos en un cuerpo <m>F</m>, entonces la matriz de <m>n \times n</m>
        <me>\begin{pmatrix}<![CDATA[
        1          & 1          & \cdots & 1 \\
        \alpha_1   & \alpha_2   & \cdots & \alpha_n \\
        \alpha_1^2 & \alpha_2^2 & \cdots & \alpha_n^2 \\
        \vdots     & \vdots     & \ddots & \vdots \\
        \alpha_1^{n-1} & \alpha_2^{n-1} & \cdots & \alpha_n^{n-1} 
        ]]>\end{pmatrix}</me>
      se llama <term>matriz de Vandermonde</term><idx><h>Matriz de Vandermonde</h></idx><idx><h>Vandermonde, matriz de</h></idx>. El determinante de esta matriz se llama <term>determinante de Vandermonde</term><idx><h>Determinante de Vandermonde</h></idx><idx><h>Vandermonde, determinante de </h></idx>.  Necesitaremos el siguiente lema en nuestro estudio de los códigos cíclicos.
    </p>

      <lemma xml:id="lemma-vandermode-det">
        <statement>
          <p>Sean <m>\alpha_1, \ldots, \alpha_n</m> elementos en un cuerpo <m>F</m> con <m>n \geq 2</m>.  Entonces
            <me>\det
            \begin{pmatrix}<![CDATA[
            1              & 1              & \cdots & 1 \\
            \alpha_1       & \alpha_2       & \cdots & \alpha_n \\
            \alpha_1^2     & \alpha_2^2     & \cdots & \alpha_n^2 \\
            \vdots         & \vdots         & \ddots & \vdots \\
            \alpha_1^{n-1} & \alpha_2^{n-1} & \cdots & \alpha_n^{n-1} 
            ]]>\end{pmatrix}
            = \prod_{1 \leq j \lt i \leq n} (\alpha_i - \alpha_j)</me>.
          En particular, si los <m>\alpha_i</m> son distintos, entonces el determinante es distinto de cero.
    </p>
        </statement>
        <proof>
          <p>Procederemos por inducción en <m>n</m>. Si <m>n = 2</m>, entonces el determinante es <m>\alpha_2 - \alpha_1</m>.  Supongamos demostrado el resultado para <m>n  - 1</m> y consideremos el polinomio <m>p(x)</m> definido por
            <me>p(x) = \det
            \begin{pmatrix}<![CDATA[
            1              & 1              & \cdots & 1              & 1 \\
            \alpha_1       & \alpha_2       & \cdots & \alpha_{n-1}   & x \\
            \alpha_1^2     & \alpha_2^2     & \cdots & \alpha_{n-1}^2 & x^2 \\
            \vdots         & \vdots         & \ddots & \vdots         & \vdots \\
            \alpha_1^{n-1} & \alpha_2^{n-1} & \cdots & \alpha_{n-1}^{n-1} & x^{n-1}
            ]]>\end{pmatrix}</me>.
          Expandiendo este determinante por cofactores en la última columna, vemos que <m>p(x)</m> es un polinomio de grado a lo más <m>n-1</m>.  Además, las raíces de <m>p(x)</m> son <m>\alpha_1, \ldots, \alpha_{n-1}</m>, pues la sustitución de cualquiera de esos elementos en la última columna producirá una columna idéntica a otra columna de la matriz.  Recuerde que el determinante de una matriz es cero si esta tiene dos columnas idénticas. Por lo tanto,     
            <me>p(x) = (x - \alpha_1)(x - \alpha_2) \cdots (x - \alpha_{n-1}) \beta</me>,
          donde
            <me>\beta = (-1)^{n + n} \det
            \begin{pmatrix}<![CDATA[
            1              & 1              & \cdots & 1 \\
            \alpha_1       & \alpha_2       & \cdots & \alpha_{n-1} \\
            \alpha_1^2     & \alpha_2^2     & \cdots & \alpha_{n-1}^2 \\
            \vdots         & \vdots         & \ddots & \vdots \\
            \alpha_1^{n-2} & \alpha_2^{n-2} & \cdots & \alpha_{n-1}^{n-2} 
            ]]>\end{pmatrix}</me>.
          Por nuestra hipótesis de inducción,
            <me>\beta = (-1)^{n+n} \prod_{1 \leq j \lt i \leq n-1} (\alpha_i - \alpha_j)</me>.
          Si evaluamos en <m>x = \alpha_n</m>, el resultados es una consecuencia inmediata.
    </p>
        </proof>
      </lemma>

      <p>El siguiente teorema nos entrega una estimación de las capacidades de detección y corrección de errores para un polinomio generador en particular.
    </p>

      <theorem xml:id="theorem-min-dist-cyclic-code">
        <statement>
          <p>Sea <m>C = \langle g(t) \rangle</m> un código cíclico en <m>R_n</m> y supongamos que <m>\omega</m> es una raíz <m>n</m>-ésima primitiva de la unidad sobre <m>{\mathbb Z}_2</m>.  Si <m>s</m> potencias consecutivas de <m>\omega</m> son raíces de <m>g(x)</m>, entonces la distacia mínima de <m>C</m> es al menos <m>s + 1</m>.
    </p>
        </statement>
        <proof>
          <p>Supongamos que  
            <me>g( \omega^r) = g(\omega^{r + 1}) = \cdots = g( \omega^{r + s - 1}) = 0</me>.
          Sea <m>f(x)</m> algún polinomio en <m>C</m> con <m>s</m> o menos coeficientes distintos de cero.  Podemos suponer que 
            <me>f(x) = a_{i_0} x^{i_0} + a_{i_1} x^{i_1} + \cdots + a_{i_{s - 1}} x^{i_{s - 1}}</me>
          es algún polinomio en <m>C</m>. Es suficiente con demostrar que todos los <m>a_i</m> tienen que ser cero.  Como 
            <me>g( \omega^r) = g(\omega^{r + 1}) = \cdots = g( \omega^{r + s - 1}) = 0</me>
          y <m>g(x)</m> divide a <m>f(x)</m>,
            <me>f( \omega^r) = f(\omega^{r + 1}) = \cdots = f( \omega^{r + s - 1}) = 0</me>.
          Equivalentemente, tenemos el siguiente sistema de ecuaciones:
            <md>
              <mrow>a_{i_0} (\omega^r)^{i_0} + a_{i_1} (\omega^r)^{i_1} + \cdots + a_{i_{s - 1}} (\omega^r)^{i_{s - 1}} &amp; = 0</mrow>
              <mrow> a_{i_0} (\omega^{r + 1})^{i_0} + a_{i_1} (\omega^{r + 1})^{i_2} + \cdots + a_{i_{s-1}} (\omega^{r+1})^{i_{s-1}} &amp; = 0</mrow><mrow>&amp; \vdots </mrow>
              <mrow>a_{i_0} (\omega^{r + s - 1})^{i_0} + a_{i_1} (\omega^{r + s - 1})^{i_1} + \cdots + a_{i_{s - 1}} (\omega^{r + s - 1})^{i_{s - 1}} &amp; = 0</mrow>
            </md>.
          Por lo tanto, <m>(a_{i_0}, a_{i_1}, \ldots, a_{i_{s - 1}})</m> es una solución del sistema de ecuaciones lineales homogéneo
            <md>
              <mrow>(\omega^{i_0})^r x_0 + (\omega^{i_1})^r x_1 + \cdots + (\omega^{i_{s - 1}})^r x_{n - 1} &amp; = 0</mrow>
              <mrow>(\omega^{i_0})^{r + 1} x_0 + (\omega^{i_1})^{r + 1} x_1 + \cdots + (\omega^{i_{s - 1}})^{r + 1} x_{n - 1} &amp; = 0</mrow>
              <mrow>&amp; \vdots </mrow>
              <mrow>(\omega^{i_0})^{r + s - 1} x_0 + (\omega^{i_1})^{r + s - 1} x_1 + \cdots + (\omega^{i_{s - 1}})^{r + s - 1} x_{n - 1} &amp; = 0</mrow>
            </md>.
          Pero este sistema tiene solución única, pues el determinante de la matriz
            <me>\begin{pmatrix}<![CDATA[
            (\omega^{i_0})^r & (\omega^{i_1})^r & \cdots & (\omega^{i_{s-1}})^r \\
            (\omega^{i_0})^{r+1} & (\omega^{i_1})^{r+1} & \cdots &
            (\omega^{i_{s-1}})^{r+1} \\
            \vdots & \vdots         & \ddots & \vdots \\
            (\omega^{i_0})^{r+s-1} & (\omega^{i_1})^{r+s-1} & \cdots &
            (\omega^{i_{s-1}})^{r+s-1} 
            ]]>\end{pmatrix}</me>
          no es cero por el <xref ref="lemma-vandermode-det" /> y las propiedades básicas de los determinantes (Ejercicio). Por lo tanto, esta solución es <m>a_{i_0} = a_{i_1} = \cdots = a_{i_{s - 1}} = 0</m>.
    </p>
        </proof>
      </theorem>

    </subsection>

    <subsection xml:id="finite-subsection-bch-codes">
      <title>Códigos <acro>BCH</acro></title>
 
      <p>Entre los códigos más importantes, descubiertos independientemente por A. Hocquenghem en 1959 y por R. C. Bose y D. V. Ray-Chaudhuri en 1960, están los códigos <acro>BCH</acro>. Los sistemas de comunicación Europeo y Trasantlántico, ambos usan códigos <acro>BCH</acro>.  Las palabras a codificar son de largo 231, y se usa un polinomio de grado 24 para generar el código.  Como <m>231 + 24 = 255 = 2^8-1</m>, tenemos un código de bloque <m>(255, 231)</m>. Este código <acro>BCH</acro> es capaz de detectar seis errores y tiene una razón de falla de 1 en 16 millones. Una ventaja de los códigos <acro>BCH</acro> es que existen algoritmos eficientes de corrección de errores para ellos.
    </p>

      <p>La idea detrás de los códigos <acro>BCH</acro> es elegir un polinomio generador de grado minimal que tenga la mayor capacidad de detección y corrección de errores. Sea <m>d = 2r + 1</m> para algún <m>r \geq 0</m>.  Supongamos que <m>\omega</m> es una raíz <m>n</m>-ésima primitiva de la unidad sobre <m>{\mathbb Z}_2</m>, y sea <m>m_i(x)</m> el polinomio minimal sobre <m>{\mathbb Z}_2</m> de <m>\omega^i</m>. Si  
        <me>g(x) = \lcm[ m_1(x), m_{2}(x), \ldots, m_{2r}(x)]</me>,
      entonces el código cíclico <m>\langle g(t) \rangle</m> en <m>R_n</m> se denomina código <term><acro>BCH</acro> de largo</term><idx><h>Código</h><h><acro>BCH</acro></h></idx> <m>n</m> y <term>distancia</term> <m>d</m>. Por el <xref ref="theorem-min-dist-cyclic-code" />, la distancia mínima de <m>C</m> es al menos <m>d</m>.
    </p>

      <theorem>
        <statement>
          <p>Sea <m>C = \langle g(t) \rangle</m> un código cíclico en <m>R_n</m>. Entonces las siguientes proposiciones son equivalentes.
            <ol>

              <li><p>El código <m>C</m> es un código <acro>BCH</acro> cuya distancia mínima es al menos <m>d</m>.
    </p></li>

              <li><p>Un polinomio <m>f(t)</m> está en <m>C</m> si y solo si <m>f( \omega^i) = 0</m> para <m>1 \leq i \lt d</m>.
    </p></li>

              <li><p>La matriz 
                <me>H =
                \begin{pmatrix}<![CDATA[
                1      & \omega      & \omega^2    & \cdots & \omega^{n-1}\\
                1      & \omega^2    & \omega^{4}  & \cdots & \omega^{(n-1)(2)} \\
                1      & \omega^3    & \omega^{6}  & \cdots & \omega^{(n-1)(3)} \\
                \vdots & \vdots      & \vdots      & \ddots & \vdots \\
                1      & \omega^{2r} & \omega^{4r} & \cdots & \omega^{(n-1)(2r)} 
                ]]>\end{pmatrix}</me>
              es una matriz verificadora para <m>C</m>.
    </p></li>

            </ol></p>
        </statement>
        <proof>
          <p>(1) <m>\Rightarrow</m> (2). Si <m>f(t)</m> está en <m>C</m>, entonces <m>g(x) \mid f(x)</m> en <m>{\mathbb Z}_2[x]</m>. Luego, para <m>i = 1, \ldots, 2r</m>, <m>f( \omega^i) = 0</m> pues <m>g( \omega^i ) = 0</m>. Recíprocamente, supongamos que <m>f( \omega^i) = 0</m> for <m>1 \leq i \leq d</m>. Entonces <m>f(x)</m> es divisible por cada <m>m_i(x)</m>, pues <m>m_i(x)</m> es el polinomio minimal de <m>\omega^i</m>. Por lo tanto, <m>g(x) \mid f(x)</m> por la definición de <m>g(x)</m>. Así, <m>f(x)</m> es una palabra del código.
    </p>

          <p>(2) <m>\Rightarrow</m> (3). Sea <m>f(t) = a_0 + a_1 t + \cdots + a_{n - 1}v t^{n - 1}</m> en <m>R_n</m>. La correspondiente <m>n</m>-tupla en <m>{\mathbb Z}_2^n</m> es <m>{\mathbf x} = (a_0 a_1 \cdots a_{n - 1})^{\rm t}</m>. Por (2),
            <me>H {\mathbf x} =
            \begin{pmatrix}<![CDATA[
            a_0 + a_1 \omega + \cdots + a_{n-1} \omega^{n-1} \\
            a_0 + a_1 \omega^2 + \cdots + a_{n-1} (\omega^2)^{n-1} \\
            \vdots \\
            a_0 + a_1 \omega^{2r} + \cdots + a_{n-1} (\omega^{2r})^{n-1}
            ]]>\end{pmatrix}
            =
            \begin{pmatrix}<![CDATA[
            f(\omega) \\
            f(\omega^2) \\
            \vdots \\
            f(\omega^{2r})
            ]]>\end{pmatrix}
            = 0</me>
          precisamente cuando <m>f(t)</m> está en <m>C</m>. Luego, <m>H</m> es una matriz verificadora para <m>C</m>.
    </p>

          <p>(3) <m>\Rightarrow</m> (1). Por (3), un polinomio <m>f(t) = a_0 + a_1 t + \cdots + a_{n - 1} t^{n - 1}</m> está en <m>C</m> exactamente cuando <m>f(\omega^i) = 0</m> for <m>i = 1, \ldots, 2r</m>. El menor tal polinomio es <m>g(t) = \lcm[ m_1(t),\ldots, m_{2r}(t)]</m>.  Por lo tanto, <m>C = \langle g(t) \rangle</m>.
    </p>
        </proof>
      </theorem>

      <example xml:id="example-finite-x15-1">
        <p>Es fácil verificar que <m>x^{15} - 1 \in {\mathbb Z}_2[x]</m> se factoriza como
          <me>x^{15} - 1 = (x + 1)(x^2 + x + 1)(x^4 + x + 1)(x^4 + x^3 + 1)(x^4 + x^3 + x^2 + x + 1)</me>,
        donde cada uno de estos factores es irreducible. Sea <m>\omega</m> una raíz de <m>1 + x + x^4</m>. El cuerpo de Galois <m>\gf(2^4)</m> es
          <me>\{ a_0 + a_1 \omega + a_2 \omega^2 + a_3 \omega^3 : a_i \in {\mathbb Z}_2 \text{ y } 1 + \omega + \omega^4 = 0 \}</me>.
        Por el <xref ref="example-finite-gf-p24" />, <m>\omega</m> es una raíz 15 primitiva de la unidad. El polinomio minimal de  <m>\omega</m> es <m>m_1(x) = 1 + x + x^4</m>. Es fácil ver que <m>\omega^2</m> y <m>\omega^4</m> también son raíces de <m>m_1(x)</m>. El polinomio minimal de <m>\omega^3</m> es <m>m_2(x) = 1 + x + x^2 + x^3 + x^4</m>. Por lo tanto, 
          <me>g(x) = m_1(x) m_2(x) = 1 + x^4 + x^6 + x^7 + x^8</me>
        tiene raíces <m>\omega</m>, <m>\omega^2</m>, <m>\omega^3</m>, <m>\omega^4</m>.  Como tanto <m>m_1(x)</m> como <m>m_2(x)</m> dividen a <m>x^{15} - 1</m>, el código <acro>BCH</acro> es un código <m>(15, 7)</m>. Si <m>x^{15} -1 = g(x)h(x)</m>, entonces <m>h(x) = 1 + x^4 + x^6 + x^7</m>; por lo tanto, una matriz verificadora para este código es
          <me>\left(   <!-- This matrix is too large for pmatrix - TWJ 8/19/2010 -->
          \begin{array}{ccccccccccccccc}
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
          \end{array}
          \right)</me>.
    </p>
      </example>

      <paragraphs>
        <title>Sage</title>
      
        <p>Los Cuerpos Finitos son importantes en diversas disciplinas aplicadas, tales como criptografía y teoría de códigos (vea la introducción a estos tópicos en otros capítulos).  Sage tiene una excelente implementación de los cuerpos finitos que permite una variedad de cálculos con éstos.
    </p>
      </paragraphs>

    </subsection>
  </section>

  <reading-questions permid="RdC">

    <exercise permid="klZ">
      <statement>
        <p permid="oVS">
          ¿Cuándo es separable una extensión de cuerpos?
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="Qti">
      <statement>
        <p permid="Vdb">
          ¿Cuáles son los posibles órdenes de los subcuerpos de un cuerpo finito?
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="wAr">
      <statement>
        <p permid="Bkk">
          ¿Cuál es la estructura de los elementos distintos de cero de un cuerpo finito?
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="cHA">
      <statement>
        <p permid="hrt">
          Proporcione una caracterización de cuerpos finitos utilizando el concepto de cuerpo de descomposición.
        </p>
      </statement>
      <response/>
    </exercise>

    <exercise permid="IOJ">
      <statement>
        <p permid="NyC">
          ¿Por qué un teorema en este capítulo se titula
<q>¿El sueño del Pibe?</q>
        </p>
      </statement>
      <response/>
    </exercise>

  </reading-questions>
    <!-- Exercises with Solutions  -->
    <!-- File: finite.xml  -->
    <!-- Title: Finite Fields -->
  <exercises xml:id="finite-exercises" filenamebase="finite" permid="KWV">
    <title>Ejercicios</title>
  
    <exercise number="1">
    <statement>
      <p>Calcule.
    </p>
  
        <ol cols="2">
  
          <li><p><m>[\gf(3^6) : \gf(3^3)]</m></p></li>
  
          <li><p><m>[\gf(128): \gf(16)]</m></p></li>
  
          <li><p><m>[\gf(625) : \gf(25) ]</m></p></li>
  
          <li><p><m>[\gf(p^{12}): \gf(p^2)]</m></p></li>
  
        </ol>
      </statement>
      <hint>
        <p>Asegúrese de tener una extensión de cuerpos.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="2">
      <statement>
        <p>Calcule <m>[\gf(p^m): \gf(p^n)]</m>, con <m>n \mid m</m>.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="3">
      <statement>
        <p>¿Cuál es el reticulado de subcuerpos de <m>\gf(p^{30})</m>?</p>
      </statement>
      
    </exercise>
  
    <exercise number="4">
      <statement>
        <p>Sea <m>\alpha</m> una raíz de <m>x^3 + x^2 + 1</m> sobre <m>{\mathbb Z}_2</m>. Construya un cuerpo finito de orden 8. Muestre que <m>x^3 + x^2 + 1</m> se descompone en <m>{\mathbb Z}_2(\alpha)</m>.
    </p>
      </statement>
      <hint>
        <p>Hay ocho elementos en <m>{\mathbb Z}_2(\alpha)</m>. Exhiba dos ceros más de <m>x^3 + x^2 + 1</m> además de <m>\alpha</m> entre estos ocho elementos.
    </p>
      </hint>
      
    </exercise>
  
    <!--Todo Complete the solution.-->
  
    <exercise number="5">
      <statement>
        <p>Construya un cuerpo finito de orden 27.
    </p>
      </statement>
      <hint>
        <p>Encuentre un polinomio irreducible <m>p(x)</m> en <m>{\mathbb Z}_3[x]</m> de grado 3 y muestre que <m>{\mathbb Z}_3[x]/ \langle p(x) \rangle</m> tiene 27 elementos.
    </p>
      </hint>
      
    </exercise>
  
    <!--Todo Complete the solution.-->
  
    <exercise number="6">
      <statement>
        <p>Demuestre o refute: <m>{\mathbb Q}^\ast</m> es cíclico.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="7">
      <statement>
        <p>Factorice cada uno de los siguientes polinomios en <m>{\mathbb Z}_2[x]</m>.
          <ol cols="2">
  
            <li><p><m>x^5- 1</m></p></li>
  
            <li><p><m>x^6 + x^5 + x^4 + x^3 + x^2 + x + 1</m></p></li>
  
            <li><p><m>x^9 - 1</m></p></li>
  
            <li><p><m>x^4 +x^3 + x^2 + x + 1</m></p></li>
  
          </ol></p>
      </statement>
      <hint>
        <p>(a) <m>x^5 -1 = (x+1)(x^4+x^3 + x^2 + x+ 1)</m>; (c) <m>x^9 -1 = (x+1)( x^2 + x+ 1)(x^6+x^3+1)</m>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="8">
      <statement>
        <p>Demuestre o refute: <m>{\mathbb Z}_2[x] / \langle x^3 + x + 1 \rangle \cong {\mathbb Z}_2[x] / \langle x^3 + x^2 + 1 \rangle</m>. </p>
      </statement>
      <hint>
        <p>Verdadero.
    </p>
      </hint>
      
    </exercise>
  
    <!--Todo Complete the solution.-->
  
    <exercise number="9">
      <statement>
        <p>Determine el número de códigos cíclicos de longitud <m>n</m> para <m>n = 6</m>, 7, 8, 10.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Complete the solution.-->
  
    <exercise number="10">
      <statement>
        <p>Demuestre que el ideal <m>\langle t + 1 \rangle</m> en <m>R_n</m> es el código en <m>{\mathbb Z}_2^n</m> que consiste de todas las palabras con un número par de unos.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Complete the solution.-->
  
    <exercise number="11">
      <statement>
        <p>Construya todos los códigos <acro>BCH</acro> de
          <ol cols="2">
  
            <li><p>longitud 7.
    </p></li>
  
            <li><p>longitud 15.
    </p></li>
  
        </ol></p>
      </statement>
      <hint>
        <p>(a) Use el hechode que <m>x^7 -1 = (x+1)( x^3 + x+ 1)(x^3+x^2+1)</m>.
    </p>
      </hint>
      
    </exercise>
  
    <!--Todo Complete the solution.-->
  
    <exercise number="12">
      <statement>
        <p>Demuestre o refute: Existe un cuerpo finito algebraicamente cerrado.
    </p>
      </statement>
      <hint>
        <p>Falso.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="13">
      <statement>
        <p>Sea <m>p</m> un primo.  Demuestre que el cuerpo de funciones racionales <m>{\mathbb Z}_p(x)</m> es un cuerpo infinito de característica <m>p</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="14">
      <statement>
        <p>Sea <m>D</m> un dominio de integridad de característica <m>p</m>.  Demuestre que <m>(a - b)^{p^n} = a^{p^n} - b^{p^n}</m> para todo <m>a, b \in D</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="15" xml:id="exercise-finite-sum-of-squares">
      <statement>
        <p>Muestre que todo elemento en un cuerpo finito puede ser escrito como la suma de dos cuadrados.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="16">
      <statement>
        <p>Sean <m>E</m> y <m>F</m> be subcuerpos de un cuerpo finito <m>K</m>. Si <m>E</m> es isomorfo a <m>F</m>, muestre que <m>E=F</m>.
    </p>
      </statement>
        
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="17">
      <statement>
        <p>Sean <m>F \subset E \subset K</m> cuerpos. Si <m>K</m> es una extensión separable de <m>F</m>, muestre que <m>K</m> también es una extensión separable de <m>E</m>.
    </p>
      </statement>
      <hint>
        <p>Si <m>p(x) \in F[x]</m>, entonces <m>p(x) \in E[x]</m>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="18">
      <statement>
          <p>Sea <m>E</m> una extensión de un cuerpo finito <m>F</m>, donde <m>F</m> tiene <m>q</m> elementos. Sea <m>\alpha \in E</m> algebraico sobre <m>F</m> de grado <m>n</m>. Demuestre que <m>F( \alpha )</m> tiene <m>q^n</m> elementos. </p>
      </statement>
      <hint>
        <p>Como <m>\alpha</m> es algebraico sobreo <m>F</m> de grado <m>n</m>, podemos escribir cualquier elemento <m>\beta \in F(\alpha)</m> de forma única como <m>\beta = a_0  + a_1 \alpha + \cdots + a_{n-1} \alpha^{n-1}</m> with <m>a_i \in F</m>. Existen <m>q^n</m> posibles <m>n</m>-tuplas <m>(a_0, a_1, \ldots, a_{n-1})</m>.
    </p>
      </hint>
      
    </exercise>
  
    <exercise number="19">
      <statement>
        <p>Muestre que toda extensión finita de un cuerpo finito <m>F</m> es simple; es decir, si <m>E</m> es una extensión finita de n cuerpo finito <m>F</m>, demuestre que existe un <m>\alpha \in E</m> tal que <m>E = F( \alpha )</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="20">
      <statement>
        <p>Muestre que para cada <m>n</m> existe un polinomio irreducible de grado <m>n</m> en <m>{\mathbb Z}_p[x]</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="21" xml:id="exercise-frobenius-map">
      <statement>
        <p>Demuestre que la <term>función de Frobenius</term> <m>\Phi : \gf(p^n) \rightarrow \gf(p^n)</m> dada por <m>\Phi : \alpha \mapsto \alpha^p</m> es un automorfismo de orden <m>n</m>.
    </p>
      </statement>
      
    </exercise>
  
    <exercise number="22">
      <statement>
        <p>Muestre que todo elemento en <m>\gf(p^n)</m> puede ser escrito en la forma <m>a^p</m> para un único <m>a \in \gf(p^n)</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="23">
      <statement>
        <p>Sean <m>E</m> y <m>F</m> subcuerpos de <m>\gf(p^n)</m>. Si <m>|E| = p^r</m> y <m>|F| = p^s</m>, ¿cuál es el orden de <m>E \cap F</m>?</p>
      </statement>
      
    </exercise>
  
    <exercise number="24">
      <title>Teoream de Wilson</title>
      <statement>
        <p>Sea <m>p</m> un primo.  Demuestre que <m>(p-1)! \equiv -1 \pmod{p}</m>.
    </p>
      </statement>
      <hint>
        <p>Factorice <m>x^{p-1} - 1</m> sobre <m>{\mathbb Z}_p</m>.
    </p>
      </hint>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="25">
      <statement>
        <p>Si <m>g(t)</m> es el polinomio generador minimal para un código cíclico <m>C</m> en <m>R_n</m>, demuestre que el término constante de <m>g(x)</m> es <m>1</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="26">
      <statement>
        <p>Es concebible que una ráfaga de errores pueda ocurrir durante una transmisión, como en el caso de una sobrecarga de energía.  Una ráfaga de interferencia puede alterar varios bits consecutivos de una palabra del código. Los códigos cíclicos permiten detectar tales ráfagas de errores. Sea <m>C</m> un código cíclico
      <m>(n,k)</m>. Demuestre que cualquier ráfaga de hasta <m>n-k</m> dígitos puede ser detectada.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="27">
      <statement>
        <p>Demuestre que los anillos <m>R_n</m> y <m>{\mathbb Z}_2^n</m> son isomorfos como espacios vectoriales.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="28">
      <statement>
        <p>Sea <m>C</m> un código en <m>R_n</m> generado por <m>g(t)</m>. Si <m>\langle f(t) \rangle</m> es otro código en <m>R_n</m>, muestre que <m>\langle g(t) \rangle \subset \langle f(t) \rangle</m> si y solo si <m>f(x)</m> divide a <m>g(x)</m> en
      <m>{\mathbb Z}_2[x]</m>.
    </p>
      </statement>
      
    </exercise>
  
    <!--Todo Finish proof.-->
  
    <exercise number="29">
      <statement>
        <p>Sea <m>C = \langle g(t) \rangle</m> un código cíclico en <m>R_n</m> y supongamos que <m>x^n - 1 = g(x) h(x)</m>, donde <m>g(x) = g_0 + g_1 x + \cdots + g_{n - k} x^{n - k}</m> y <m>h(x) = h_0 + h_1 x +  \cdots + h_k x^k</m>. Definamos <m>G</m> como la matriz de  <m>n \times k</m>
          <me>G = 
          \begin{pmatrix}
          g_0 &amp; 0   &amp; \cdots &amp; 0 \\
          g_1 &amp; g_0 &amp; \cdots &amp; 0 \\
          \vdots &amp; \vdots &amp;\ddots &amp; \vdots \\
          g_{n-k}   &amp; g_{n-k-1} &amp; \cdots &amp; g_0 \\
          0   &amp; g_{n-k} &amp; \cdots &amp; g_{1} \\
          \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
          0   &amp; 0 &amp; \cdots &amp; g_{n-k}
          \end{pmatrix}</me>
        y <m>H</m> como la matriz de <m>(n-k) \times n</m>
          <me>H =
          \begin{pmatrix}
          0   &amp; \cdots &amp; 0   &amp; 0      &amp; h_k    &amp; \cdots &amp; h_0 \\
          0   &amp; \cdots &amp; 0   &amp; h_k    &amp; \cdots &amp; h_0    &amp; 0 \\
          \cdots &amp; \cdots &amp; \cdots  &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots  \\
          h_k &amp; \cdots &amp; h_0 &amp; 0      &amp; 0      &amp; \cdots &amp; 0 
          \end{pmatrix}</me>.
          <ol>
  
            <li><p>Demuestre que <m>G</m> es una matriz generadora para <m>C</m>.
    </p></li>
  
            <li><p>Demuestre que <m>H</m> es una matriz verificadora para <m>C</m>.
    </p></li>
  
            <li><p>Muestre que <m>HG = 0</m>.
    </p></li>
  
          </ol></p>
      </statement>
      
    </exercise>
  
  </exercises>

  <exercises xml:id="finite-exercises-bch-codes">
    <title>Ejercicios Adicionales: Corrección de Errores para Códigos <acro>BCH</acro></title>

    <introduction>
      <p>Los códigos <acro>BCH</acro> tienen algoritmos de corrección de errores muy atractivos. Sea <m>C</m> un código <acro>BCH</acro> en <m>R_n</m>, y supongamos que se transmite un polinomio <m>c(t) = c_0 + c_1 t + \cdots + c_{n-1} t^{n-1}</m> del código. Sea <m>w(t) = w_0 + w_1 t + \cdots w_{n-1} t^{n-1}</m> el polinomio en <m>R_n</m> que es recibido.  Si han ocurrido errores en los bits <m>a_1, \ldots, a_k</m>, entonces <m>w(t) = c(t) + e(t)</m>, donde <m>e(t) = t^{a_1} + t^{a_2} + \cdots + t^{a_k}</m> es el <term>polinomio de error</term><idx><h>Polinomio</h><h>de error</h></idx>. El decodificador debe determinar los enteros <m>a_i</m> y luego recuperar <m>c(t)</m> a partir de <m>w(t)</m> cambiando el valor de los bit <m>a_i</m>. A partir de <m>w(t)</m> podemos calcular <m>w( \omega^i ) = s_i</m> para <m>i = 1, \ldots, 2r</m>, donde <m>\omega</m> es una raíz <m>n</m>-ésima primitiva de la unidad sobre <m>{\mathbb Z}_2</m>. Decimos que el <term>síndrome</term><idx><h>Síndrome de un código</h></idx> de <m>w(t)</m> es <m>s_1, \ldots, s_{2r}</m>.
    </p>
    </introduction>

    <exercise>
      <statement>
        <p>Muestre que <m>w(t)</m> es un código polinomial si y solo si <m>s_i = 0</m> para todo <m>i</m>.
    </p>
      </statement>
    </exercise>

    <exercise>
      <statement>
        <p>Muestre que 
          <me>s_i = w( \omega^i) = e( \omega^i) = \omega^{i a_1} + \omega^{i a_2} + \cdots + \omega^{i a_k}</me>
        para <m>i = 1, \ldots, 2r</m>. El <term>polinomio localizador de errores</term><idx><h>Polinomio</h><h>localizador de errores</h></idx> se define como
          <me>s(x) = (x + \omega^{a_1})(x + \omega^{a_2}) \cdots  (x + \omega^{a_k})</me>.
    </p>
      </statement>
    </exercise>

    <exercise>
      <statement>
        <p>Recuerde el código de bloque <acro>BCH</acro> <m>(15,7)</m> en el <xref ref="example-finite-parity-check-x7-1" />.  Por el <xref ref="theorem-min-distance" />, este código es capaz de corregir dos errores. Supongamos que estos errores ocurren en los bits <m>a_1</m> y <m>a_2</m>. El polinomio localizador de errores es <m>s(x) = (x + \omega^{a_1})(x + \omega^{a_2})</m>. Muestre que
          <me>s(x) = x^2 + s_1 x + \left( s_1^2 + \frac{s_3}{s_1} \right)</me>.
    </p>
      </statement>
    </exercise>

    <exercise>
      <statement>
        <p>Sea <m>w(t) = 1 + t^2 +t^4 + t^5 + t^7 + t^{12} + t^{13}</m>. Determine el polinomio originalmente transmitido.
    </p>
      </statement>
    </exercise>

  </exercises>

  <references xml:id="finite-references">
    <title>Referencias y Lecturas Recomendadas</title>

    <biblio type="raw"> <!-- was [1] -->
<!-- Reference updated 5/4/2010 - TWJ -->
    Childs, L. <title>A Concrete Introduction to Higher Algebra</title>. 2nd ed. Springer-Verlag, New York, 1995.
    </biblio>

    <biblio type="raw"> <!-- was [2] -->
<!-- No longer in print 8/20/2010 - TWJ -->
    Gåding, L. and Tambour, T. <title>Algebra for Computer Science</title>. Springer-Verlag, New York, 1988.
    </biblio>

    <biblio type="raw"> <!-- was [3] -->
<!-- Reference updated 8/20/2010 - TWJ -->
    Lidl, R. and Pilz, G. <title>Applied Abstract Algebra</title>. 2nd ed. Springer, New York, 1998. An excellent presentation of finite fields and their applications.
    </biblio>

    <biblio type="raw"> <!-- was [4] -->
<!-- No longer in print 8/20/2010 - TWJ -->
    Mackiw, G. <title>Applications of Abstract Algebra</title>. Wiley, New York, 1985.
    </biblio>

    <biblio type="raw"> <!-- was [5] -->
    Roman, S. <title>Coding and Information Theory</title>. Springer-Verlag, New York, 1992.
    </biblio>

    <biblio type="raw"> <!-- was [6] -->
<!-- Reference updated - TWJ 8/20/2010 -->
    van Lint, J. H. <title>Introduction to Coding Theory</title>. Springer, New York, 1999.
    </biblio>

  </references>

  <section xml:id="finite-sage">
    <title>Sage</title>
  
    <introduction>
      <p>Habrá notado en este capítulo que los cuerpos finitos son bastante estructurados.  También henos visto cuerpos finitos en Sage como ejemplos de anillos y cuerpos.  Ahora podemos combinar los dos, principalmente usando comandos que ya conocemos, además de unos pocos nuevos.
    </p>
    </introduction>
  
  
    <subsection>
      <title>Creando Cuerpos Finitos</title>
  
      <p>Por el <xref ref="theorem-finite-splitting-field" /> sabemos que todos los cuerpos finitos de un orden dado son isomorfos y que los órdenes posibles se limitan a las potencias de primos.  Podemos usar el comando <c>FiniteField()</c>, como antes, o uno equivalente más corto que es <c>GF()</c>.  Opcionalmente, podemos especificar un polinomio irreducible para la construcción del cuerpo.  Podemos ver este polinomio como el generador del ideal principal de un anillo de polinomios, o lo podemos ver como una regla de <q>re-escritura</q> para las potencias del generador del cuerpo que nos permite multiplicar elementos y reformularlos como combinaciones lineales de potencias menores.
    </p>
  
      <p>De no proveerse un polinomio irreducible, Sage usará un polinomio de Conway.  Usted puede determinarlos con el comando <c>conway_polynomial()</c>, o simplemente construir un cuerpo finito y recuperar el polinomio que lo define con el método <c>.polynomial()</c>.
    </p>
  
      <sage>
      <input>
      F.&lt;a&gt; = GF(7^15); F
      </input>
      <output>
      Finite Field in a of size 7^15
      </output>
      </sage>
  
      <sage>
      <input>
      F.polynomial()
      </input>
      <output>
      a^15 + 5*a^6 + 6*a^5 + 6*a^4 + 4*a^3 + a^2 + 2*a + 4
      </output>
      </sage>
  
      <sage>
      <input>
      a^15 + 5*a^6 + 6*a^5 + 6*a^4 + 4*a^3 + a^2 + 2*a + 4
      </input>
      <output>
      0
      </output>
      </sage>
  
      <sage>
      <input>
      conway_polynomial(7, 15)
      </input>
      <output>
      x^15 + 5*x^6 + 6*x^5 + 6*x^4 + 4*x^3 + x^2 + 2*x + 4
      </output>
      </sage>
  
      <p>Solo para facilitar la lectura, coercionamos una lista de coeficientes al anillo de polinomios (obtenido con el método <c>.parent()</c> en un polinomio simple) para definir un polinomio.
    </p>
  
      <sage>
      <input>
      y = polygen(Integers(7), 'y')
      P = y.parent()
      p = P([4, 5, 2, 6, 3, 3, 6, 2, 1, 1, 2, 5, 6, 3, 5, 1]); p
      </input>
      <output>
      y^15 + 5*y^14 + 3*y^13 + 6*y^12 + 5*y^11 + 2*y^10 + y^9 +
      y^8 + 2*y^7 + 6*y^6 + 3*y^5 + 3*y^4 + 6*y^3 + 2*y^2 + 5*y + 4
      </output>
      </sage>
  
      <sage>
      <input>
      p.is_irreducible()
      </input>
      <output>
      True
      </output>
      </sage>
  
      <sage>
      <input>
      T.&lt;b&gt; = GF(7^15, modulus=p); T
      </input>
      <output>
      Finite Field in b of size 7^15
      </output>
      </sage>
    </subsection>
  
    <subsection>
      <title>Logaritmos en Cuerpos Finitos</title>
  
      <p>Un comando útil que no hemos descrito es el método <c>.log()</c> para elementos de un cuerpo finito.  Como sabemos que el grupo multiplicativo de elementos distintos de cero es cíclico, podemos expresar cualquier elemento como una potencia del generador.  El método <c>.log()</c> devuelve esa potencia.
    </p>
  
      <p>Usualmente querremos usar el generador como la base de un cálculo de logaritmos en el cuerpo finito.  Pero también es posible usar otra base, en el entendimiento que si la base no es un generador del grupo, entonces el logaritmo podría no existir (<ie /> puede no haber una solución a la ecuación relevante).
    </p>
  
      <sage>
      <input>
      F.&lt;a&gt; = GF(5^4)
      a^458
      </input>
      <output>
      3*a^3 + 2*a^2 + a + 3
      </output>
      </sage>
  
      <sage>
      <input>
      (3*a^3 + 2*a^2 + a + 3).log(a)
      </input>
      <output>
      458
      </output>
      </sage>
  
      <sage>
      <input>
      exponent = (3*a^3 + 2*a^2 + a + 3).log(2*a^3 + 4*a^2 + 4*a)
      exponent
      </input>
      <output>
      211
      </output>
      </sage>
  
      <sage>
      <input>
      (2*a^3 + 4*a^2 + 4*a)^exponent == 3*a^3 + 2*a^2 + a + 3
      </input>
      <output>
      True
      </output>
      </sage>
  
      <sage>
      <input>
      (3*a^3 + 2*a^2 + a + 3).log(a^2 + 4*a + 4)
      </input>
      <output>
      Traceback (most recent call last):
      ...
      ValueError: No discrete log of 3*a^3 + 2*a^2 + a + 3 found
      to base a^2 + 4*a + 4
      </output>
      </sage>
  
      <p>Como ya conocemos muchos comandos en Sage, no hay mucho más que sea necesario introducir para trabajar provechosamente con cuerpos finitos. Los ejercicios exploran formas en que podemos examinar y aprovechar la estructura de los cuerpos finitos en Sage.
    </p>
  
    </subsection>
  
  </section>
  
  <exercises xml:id="finite-sage-exercises">
    <title>Ejercicios en Sage</title>
  
    <exercise number="1">
      <statement>
        <p>Cree un cuerpo finito de orden <m>5^2</m> y factorice <m>p(x)=x^{25}-x</m> sobre este cuerpo.  Comente sobre qué es lo interesante de este resultado y por qué no es una sorpresa.
    </p>
      </statement>
  
      
    </exercise>
  
    <exercise number="2">
      <statement>
        <p>El Corolario<nbsp/><xref ref="corollary-cyclic-group-finite-field"/> dice que los elementos distintos de cero de un cuerpo finito forman un grupo cíclico con la multiplicación.  El generador usado en Sage es también un generador de este grupo multiplicativo.  Para ver esto, cree un cuerpo finito de orden <m>2^7</m>.  Cree dos listas de los elementos del cuerpo: primero, use el método <c>.list()</c>, luego use una lista por comprensión para generar las potencias del generador especificado en la creación del cuerpo.
    </p>
  
        <p>A la segunda lista le faltará el cero para ser el cuerpo completo. Cree el elemento 0 del cuerpo (quizás coercionando <m>0</m> para que pertenezca al cuerpo) y agréguelo a la lista de potencias usando <c>.append()</c>.  Use el comando <c>sorted()</c> con cada una de las listas y verifique la igualdad.
    </p>
      </statement>
  
      
    </exercise>
  
    <exercise number="3">
      <statement>
        <p>Los subcuerpos de un cuerpo finito están completamente clasificados por el Teorema<nbsp/><xref ref="theorem-finite-subfields"/>.  Es posible crear dos cuerpos finitos de los órdenes apropiados para que se cumpla la relación de extensión/subcuerpo, y traducir de uno a otro. Pero en este ejericicio construiremos un subcuerpo de un cuerpo finito desde cero.  Como el grupo de elementos distintos de cero en un cuerpo finito es cíclico, los elementos distintos de cero de un subcuerpo formarán un subgrupo del grupo cíclico, que necesariamente será cíclico.
    </p>
  
        <p>Cree un cuerpo finito de orden <m>3^6</m>.  La teoría dice que existe un subcuerpo de orden <m>3^2</m>, pues <m>2|6</m>.  Determine un generador de orden multiplicactivo <m>8</m> para los elementos distintos de cero de este subcuerpo, y construya estos <m>8</m> elementos.  Agregue el elemento cero del cuerpo a esta lista.  Debiera ser claro que este conjunto de <m>9</m> elementos es cerrado bajo multiplicación.  En ausencia de nuestros teoremas sobre cuerpos finitos y grupos cíclicos, la clausura bajo la suma no es obvia.  Escriba una línea que verifique si este conjunto es cerrado bajo sumas, considerando todas la posibles sumas de elementos del conjunto.
    </p>
      </statement>
  
      
    </exercise>
  
    <exercise number="4">
      <statement>
        <p>Este problema investiga la <q>separabilidad</q> de <m>{\mathbb Q}(\sqrt{3},\sqrt{7})</m>.  Usted puede crear este cuerpo de números rápidamente con el constructor <c>NumberFieldTower</c>, junto con los polinomios <m>x^2-3</m> y <m>x^2-7</m>.  Aplane la torre con el método <c>.absolute_field()</c> y use el método <c>.structure()</c> para recuperar los isomorfismos entre la torre y la versión plana del cuerpo.  Nombre a la torre como <c>N</c> y use  <c>a</c> y <c>b</c> como generadores.  Nombre la versión plana como <c>L</c> con <c>c</c> como generador.
    </p>
  
        <p>Cree un elemento no trivial (<q>aleatorio</q>) de <c>L</c> usando tantas potencias de <c>c</c> como sea posible (verifique el grado de <c>L</c> para ver cuántas potencias linealmente independientes existen).  Solicite a Sage el polinomio minimal de su elemento aleatorio, asegurando así que el elemento es una raíz.  Construya ese polinomio minimal como polinomio sobre <c>N</c>, la torre de cuerpos, y encuentre su factorización.  Esta factorización debiese tener solo factores lineales.  Cada raíz debiese ser una expresión en <c>a</c> y <c>b</c>.  Convierta cada raíz en una expresión con notación matemática que involucre <m>\sqrt{3}</m> y <m>\sqrt{7}</m>.  Use una de las funciones para verificar que una de las raíces corresponde al elemento aleatorio original.
    </p>
  
        <p>Cree unos pocos elementos aleatorios más, y encuentre una factorización (en <c>N</c> o en <c>L</c>).  Para que un cuerpo sea separable, todo elemento del cuerpo debe ser una raíz de <em>algún</em> polinomio separable.  El polinomio minimal es un buen polinomio para probar.  (¿Por qué?)  Basado en esta evidencia, ¿parece que <m>{\mathbb Q}(\sqrt{3},\sqrt{7})</m> fuera una extensión separable?</p>
      </statement>
  
      
    </exercise>
  
    <exercise number="5">
      <statement>
        <p>El Ejercicio<nbsp/><xref ref="exercise-frobenius-map"/> describe el automorfismo de Frobenius de un cuerpo finito.  Si <c>F</c> es un cuerpo finito en Sage, entonces <c>End(F)</c> creará el grupo de automorfismos de <c>F</c>.
    </p>
  
        <ol>
          <li><p>Trabaje el Ejercicio<nbsp/><xref ref="exercise-frobenius-map"/> para mejorar su comprensión de como y por qué la función de Frobenius es un automorfismo de cuerpos.  (Lo que viene será más sencillo si hace esto primero.)</p></li>
  
          <li><p>Para algunos cuerpos finitos pequeños, pero no triviales identifique el automorfismo de Frobenius dentro del grupo de automorfismos.  Pequeños podría significar <m>p=2,3,5,7</m> y <m>3\leq n\leq 10</m>, con <m>n</m> primo versus compuesto.
    </p></li>
  
          <li><p>Una vez que haya identificado la función de Frobenius, describa los demás automorfismos.  En otras palabras, con un poco de investigación, debiese ser posible dar una descripción de los automorfismos que le permita predecir correctamente el grupo completo de automorfismos de un cuerpo finito que no haya explorado aún.  (Ayuda: el grupo de automorfismos del grupo es un grupo.  ¿Qué pasa si <q>hace la operación</q> de la función de Frobenius consigo misma?  ¿Qué es exactamente esta operación?  Intente usar la notación multiplicativa de Sage con los elementos del grupode automorfismos.)</p></li>
  
          <li><p>¿Cuál es la <q>estructura</q> del grupo de automorfismos?  ¿Cuál es el rol especial de la función de Frobenius en este grupo?</p></li>
  
          <li><p>Para cualquier cuerpo, el subcuerpo conocido como cuerpo fijo es una construcción importantes, y será lo será más aún en el siguiente capítulo.  Dado un automorfismo <m>\tau</m> de un cuerpo <m>E</m>, se puede demostrar que el subconjunto, <m>K=\{b\in E\mid\tau(b)=b\}</m>, es un subcuerpo de <m>E</m>.  Se conoce como el <term>cuerpo fijo</term> de <m>\tau</m> en <m>E</m>.  Para cada automorfismo de <m>E=GF(3^6)</m> identifique su cuerpo fijo.  Como entendemos la estructura de subcuerpos de un cuerpo finito, es suficiente con determinar el orden de un cuerpo fijo para identificarlo completamente.
    </p></li>
        </ol>
  
      </statement>
  
      
    </exercise>
  
    <exercise number="6">
      <statement>
        <p>El Ejercicio<nbsp/><xref ref="exercise-finite-sum-of-squares"/> sugiere que todo elemento de un cuerpo finito puede ser escrito (expresado) como suma de cuadrados.  Acá se sugieren experimentos computacionales que pueden ayudarle a formular una demostración del ejercicio.
    </p>
  
        <ol>
          <li><p>Construya dos cuerpos pequeños pero no demasiado pequeños, uno con <m>p=2</m> y el otro con un primo impar.  Repita lo siguiente con cada cuerpo <m>F</m>.
    </p></li>
  
          <li><p>Escoja un elemento <q>aleatorio</q> del cuerpo, digamos <m>a\in F</m>.  Construya los conjuntos <md>
            <mrow>&amp;\{x^2|x\in F\}&amp;&amp;\{a-x^2|x\in F\}</mrow>
          </md> usando conjuntos Sage con el constructor <m>Set()</m>.  (Cuidado: <c>set()</c> es un comando Python que se comporta de forma fundamentalmente diferente.)</p></li>
  
          <li><p>Examine el tamaño de los dos conjunto y el tamaño de su intersección (<c>.intersection()</c>).  Pruebe con diferentes elementos <m>a</m>, quizás usando un bucle para probar <em>todos</em> los valores posibles. Note que <m>p=2</m> se comportará de forma bastante diferente.
    </p></li>
  
          <li><p>Supongamos que tiene un elemento de la intersección.  (Puede obtener uno con el método <c>.an_element()</c>.)  ¿Cómo lleva esto a la suma de cuadrados propuesta en el ejercicio?</p></li>
  
          <li><p>¿Puede escribir una función en Python que reciba un cuerpo finito cuyo orden sea una potencia de un primo impar y luego liste cada elemento como suma de cuadrados?</p></li>
        </ol>
  
      </statement>
  
      
    </exercise>
  
  </exercises>

</chapter>
